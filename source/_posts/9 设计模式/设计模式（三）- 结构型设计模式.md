---
title: 设计模式（三）
date: 2020-6-12
tags: [设计模式]
---
{% asset_img image1.jpg 设计模式 %}

# 设计模式（三）
<!--more-->

## 4 结构型设计模式

- 适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、亨元模式

### 4.1 适配器模式（Adapter）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适配器模式解决，一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。适配器模式分为：**类适配器、对象适配器和缺省适配器**三种实现。

> 题引：中国民用交流电220V，50Hz。美国民用交流电110V，60Hz。国内生产的某款手机充电器标准是输入220V电压输出5V电压，所以如果拿着国产的手机去美国显然是无法使用的，此时就需要一款转换器加装在国产手机充电器上，使能够正常在美国使用。



**类适配器**

{% asset_img designpattern1.png 设计模式 %}



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**类适配器采用继承被适配对象和实现目标接口来完成**，如上图，要想国产手机充电器可以在美国使用就需要使用美国标准的110V电压输入和国产充电器5V输出充电使用。

```java
// 美国充电器标准
public interface IAmericaCharger {
    void inVoltage110(String in); // 110V
    void outVoltage5();
    void charge();
}

// 中国充电器标准
public interface IChinaCharger {
    void inVoltage220(String in); // 220V
    void outVoltage5();
    void charge();
}

// 国产某手机充电器
public class ChinaCharger implements IChinaCharger {
    public void inVoltage220(String in) {}
    public void outVoltage5() {}
    public void charge() {}
}

// 国产充电器的适配器，适配美国标准使用
public class ChargerAdapter extends ChinaCharger implements IAmericaCharger {
    public void inVoltage110(String in) {
        super.inVoltage220(in); // 输入转换，国产充电器可以在美国使用
    }
    // 输出标准outVoltage5和充电标准charge，与国产充电器标准一致，即已经在父类中被调用，无需重写方法。
}
```

根据组合/聚合复用原则，很明显类适配器使用了继承方式而非组合/聚合方式，所以更常用的则是使用聚合方式的对像适配器



**对像适配器**

{% asset_img designpattern2.png 设计模式 %}



对像适配器采用聚合的方式使用，降低了对象之间的耦合性。

```java
// 国产充电器的适配器，适配美国标准使用
public class ChargerAdapter implements IAmericaCharger {
    
    private IChinaCharger chinaCharger;
    
    public ChargerAdapter(IChinaCharger chinaCharger) {
        this.chinaCharger = chinaCharger;
    }
    
    public void inVoltage110(String in) {
        super.inVoltage220(in); // 输入转换，国产充电器可以在美国使用
    }
    
    public void outVoltage5() {
        super.outVoltage5();
    }
    
    public void charge() {
        super.charge();
    }
    
}
```



**缺省适配器**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。这是为了方便建立一个不平庸的适配器类而提供的一种平庸实现。

> “国际充电器组织” 制订了统一的充电标准，然而每个地区或国家的具体实现都不相同，这就要求在“国际标准”和“落地方案”中采用一个中间缺省抽象层，用于一种更大众和均匀的实现，个别国家则可以在此基础上自己指定具体实现方案。

```java
// 国际充电器标准
public interface IInternationalCharger {
    void inVoltage(String in); 
    void outVoltage();
    void charge();
}

// 缺省适配器抽象类
public abstract AbstractChargerAdapter implements IInternationalCharger {
    public void inVoltage(String in) {
        // 国际上普遍使用220V，那么缺省适配器就用220V作为普遍实现标准
    }
    
    public void outVoltage() {
        // 采用普遍使用的5V输出
    }
    public void charge() {}
}

// 中国适配器采用国际标准
public class ChinaCharger extends AbstractChargerAdapter {
    // 中国与国际接轨，标准一致，无需重写
}

// 美国适配器采用国际标准
public class AmericaCharger extends AbstractChargerAdapter {
    // 重写输入标准，其他标准一致无需重写

    @Override
    public void inVoltage(String in) {
        // 美国重写输入标准采用110V
    }
}


```



### 4.2 装饰模式（Decoration）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;装饰模式可以动态的往对象行为（方法）上添加附加行为，灵活应用了子类覆写父类方法的特性，可以提供比继承更有弹性的替代方案。装饰模式中具有以下几种特点:

- 抽象角色：要包装的原始类，属于抽象类或接口。
- 具体抽象角色：具体被装饰的对象，属于抽象角色的实现类。
- 装饰类：继承或实现抽象角色，并使用抽象角色的聚合态作为成员变量调用方法，一般为抽象类。
- 装饰实现类：动态添加附属行为的类，是装饰类的实现类。



> 题引：有一杯纯水，通过装饰类往水中动态的添加各种东西，比如加点柠檬，加些冰块或者放点茶叶进去。最终将纯水变为我们需要的饮品。

{% asset_img designpattern3.png 设计模式 %}



```java
// 抽象角色
interface IWater {
    String getFeature(); // 水里有什么
}

// 抽象角色实现类，一杯纯纯的水
class Water implements IWater {
    @Override
    public String getFeature() {
        return "pure water";
    }
}
```

接下来定义水的装饰类和装饰实现类，通过子类实现不同的添加功能

```java
// 抽象装饰类，持有水的接口对象
abstract class WaterDecoration implements IWater {
    IWater water ;
    public WaterDecoration(IWater water) {
        this.water = water;
    }

    public String getFeature() {
        return water.getFeature();
    }
}

// 加入柠檬变成柠檬水
class LemonWater extends WaterDecoration {
    public LemonWater(IWater water) {
        super(water);
    }

    @Override
    public String getFeature() {
        return super.getFeature() + " with lemon";
    }
}

// 加入冰，让它称为一杯冰水
class IceWater extends WaterDecoration {
    public IceWater(IWater water) {
        super(water);
    }

    @Override
    public String getFeature() {
        return super.getFeature() + " with ice";
    }
}

// 加入茶叶
class TeaWater extends WaterDecoration {
    public TeaWater(IWater water) {
        super(water);
    }

    @Override
    public String getFeature() {
        return super.getFeature() + " with tea";
    }
}
```

下列测试，动态添加佐料进去

```java
// 伪代码
IWater water = new Water();
water = new LemonWater(water);
water = new IceWater(water);
water = new TeaWater(water);
System.out.println(water.getFeature());

// 输出
// pure water with lemon with ice with tea
```

如果只有一个抽象角色的实现类时，可以将装饰类直接继承使用

{% asset_img designpattern4.png 设计模式 %}

```java
static class Water implements IWater {
    @Override
    public String getFeature() {
        return "pure water";
    }
}

static abstract class WaterDecoration extends Water {
    Water water ;
    public WaterDecoration(Water water) {
        this.water = water;
    }

    public String getFeature() {
        return water.getFeature();
    }
}
```



### 4.3 代理模式（Proxy）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代理模式被广泛的应用于框架产品比如Spring和Mybatis，代理模式可以分为：**静态代理、JDK动态代理和CGLIB代理**。



**静态代理**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态代理通过代理类实现接口或继承抽象类，并与实际被代理对象通过聚合方式产生调用关系。

> 题引：要举办一场婚礼，除了婚宴以外还需要找婚庆公司订车队、订司仪、婚礼现场布置等等前置工作，还有答谢宾客等后置动作。

{% asset_img designpattern5.png 设计模式 %}



```java
interface IWedding {
    void wedding();
}

class Wedding implements IWedding {
    @Override
    public void wedding() {
        System.out.println("举办婚礼");
    }
}

class WeddingProxy implements IWedding {
    IWedding wedding;
    public WeddingProxy(IWedding wedding) {
        this.wedding = wedding;
    }
    
    @Override
    public void wedding() {
        System.out.println("找婚庆公司");
        System.out.println("布置现场");
        wedding.wedding();
        System.out.println("答谢宾客");
    }
}

// 测试伪代码
IWedding wedding = new Wedding();
IWedding proxy = new WeddingProxy(wedding);
proxy.wedding();
// 输出
// 找婚庆公司
// 布置现场
// 举办婚礼
// 答谢宾客
```

静态代理在编译阶段即可确定，需要通过代理类持有被代理对象的实例，并实现代理对象接口或抽象类的方法，从而达到扩展的目的。



**JDK动态代理**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK动态代理利用Java反射机制，在运行期创建对对象的代理实现功能扩展，无需显示的创建代理类，只需要创建代理处理器即可完成。JDK代理要求被代理对象必须实现接口，否则无法使用。

```java
public class WeddingProxyHandler implements InvocationHandler {

    private Object proxyObject;

    public WeddingProxyHandler(final Object proxyObject) {
        this.proxyObject = proxyObject;
    }

    // Object proxy参数指代理对象本身
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("找婚庆公司");
        System.out.println("布置现场");
        Object result = method.invoke(proxyObject, args);
        System.out.println("答谢宾客");
        return result;
    }
}

// 测试伪代码
IWedding wedding = new Wedding();
ClassLoader classLoader = IWedding.class.getClassLoader();
Class[] interfaces = wedding.getClass().getInterfaces();
WeddingProxyHandler proxy = new WeddingProxyHandler();
IWedding proxy = Proxy.newProxyInstance(classLoader, interfaces, proxy);
proxy.wedding();

// 输出与静态代理一致
```

出于Java机制的限制，一个类无法存在多继承关系，所以JDK动态代理始终需要通过接口完成代理而无法针对父类进行代理。



**CGLIB代理**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK代理从源码层面采用反射机制完成代理，在类加载阶段因为只是创建实例类所以该阶段执行效率高，而在运行期不断的通过反射完成所以该阶段效率并不高。相反的，CGLIB代理原理是通过ASM技术，采用动态修改字节码，在加载期向字节码写入代理功能，所以类加载阶段效率不如JDK代理，但是一旦创建实例类，在运行期就会被当作普通对象来正常使用，所以在运行期效率远高于JDK代理。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此之外，JDK动态代理只能代理实现接口的对象，而CGLIB代理不仅可以实现非接口类的代理，目前也支持实现接口对象的代理。所以在Spring的选择中，如果对象实现接口默认采用动态代理，除此之外都使用CGLIB代理，当然也可以强制要求实现接口的对象也使用CGLIB代理。

```java
class Wedding {
    @Override
    public void wedding() {
        System.out.println("举办婚礼");
    }
}

class WeddingProxy implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] params, MethodProxy proxy)
    	throws Throwable{
        System.out.println("找婚庆公司");
        System.out.println("布置现场");
        Object result = proxy.invokeSuper(o, params);
        System.out.println("答谢宾客");
        return result;
    }
}

// 使用，伪代码
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(Wedding.class);
enhancer.setCallback(new WeddingProxy());
Wedding wedding = (Wedding) enhancer.create();
wedding.wedding();

// 输出结果同上
```



### 4.4 外观模式（Facade）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观模式相对容易理解，它更像是一种面板，通过面板可以执行很多操作。如今复杂系统会由多个子系统组成，对于用户来说，一个用户面向多个子系统是一件很烦躁的事情，外观模式可以把子系统整合使用户只正对一个面板类，通过面板类可以执行内部分装的各类子系统。符合迪米特原则，但违反了开闭原则。

> 题引：如今的全自动洗衣机不仅可以洗衣、甩干、侵泡，还可以提供除螨、高温杀菌、定时清洗等诸多功能，用户通过面板按键可以轻松执行对应的功能。

{% asset_img designpattern6.png 设计模式 %}

```java
// Facade门面类
public class WashingMachineMenu {
    private MainFunction mainFunction;
    private AssistantFunction assistant;
    private DetergentFunction detergent;
    
    public WashingMachineMenu(MainFunction mainFunction, 
                              AssistantFunction assistant,
                              DetergentFunction detergent) {
        this.mainFunction = mainFunction;
        this.assistant = assistant;
        this.detergent = detergent;
    }
    
    public void wash() {
        mainFunction.wash();
    }
    public void dry() {
        mainFunction.dry();
    }
    public void soak() {
        mainFunction.soak();
    }
    public void antiAcne() {
        assistant.antiAcne();
    }
    public void sterilize() {
        assistant.sterilize();
    }
    public void schedual() {
        assistant.schedual();
    }
    public void addPowder() {
        detergent.addPowder();
    }
    public void addLiquid() {
        detergent.addLiquid();
    }
    public void addSoftener() {
        detergent.addSoftener();
    }
}

// 各子系统
class MainFunction {
    public void wash() {
       //
    }
    public void dry() {
       //
    }
    public void soak() {
       //
    }
}

class AssistantFunction {
    public void antiAcne() {
       //
    }
    public void sterilize() {
       //
    }
    public void schedual() {
       //
    }
}

class DetergentFunction {
    public void addPowder() {
       //
    }
    public void addLiquid() {
       //
    }
    public void addSoftener() {
       //
    }
}
```



### 4.5 桥接模式（Bridge）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将实现与抽象放在两个不同的层次，使两个层次隔离，修改互不影响。假如在实际应用中，某个类存在多个独立变化的维度，可以通过桥接模式将维度拆分为两层独立结构，互相扩展互不影响。通常需要识别类的两个层次分别定义抽象类和接口，使抽象类聚合接口，分别拓展两个层次抽象的具体实现。

> 题引：市场上有很多品牌的各类家用电器，比如美的空调、美的洗衣机、美的扫地机器人、海尔空调、海尔洗衣机、海尔扫地机器人、格力空调、格力扫地机器人等等。通过桥接模式实现，并支持扩展品牌和商品的扩展能力。

{% asset_img designpattern7.png 设计模式 %}



首先，定义家用电器接口及其实现类。

```java
public interface IAppliance {
	String type();
}

// 洗衣机
class WashingMachine implements IAppliance {
    private final String type = "washing machine";
    
    public String type() {
		return type;
    }
}

// 空调
class AirConditioner implements IAppliance {
    private final String type = "air conditioner";
    
    public String type() {
		return type;
    }
}

// 扫地机器人
class SweepRobot implements IAppliance {
    private final String type = "sweep robot";
    
    public String type() {
		return type;
    }
}
```



接下来定义品牌抽象类及其实现类。

```java
abstract class AbstractBrand {
    private IAppliance appliance;
    
    public AbstractBrand(IAppliance appliance) {
        this.appliance = appliance;
    }
    
    public abstract void description();
}

// 美的
class MideaBrand extends AbstractBrand {
    private final String brandName = "Midea";
    
    public MideaBrand(IAppliance appliance) {
        super(appliance);
    }
    
    public void description() {
        System.out.printf("%s of %s \n", appliance.type, brandName);
    }
}

// 海尔
class HaierBrand extends AbstractBrand {
    private final String brandName = "Haier";
    
    public HaierBrand(IAppliance appliance) {
        super(appliance);
    }
    
    public void description() {
        System.out.printf("%s of %s \n", appliance.type, brandName);
    }
}

// 格力
class GreeBrand extends AbstractBrand {
    private final String brandName = "Gree";
    
    public GreeBrand(IAppliance appliance) {
        super(appliance);
    }
    
    public void description() {
        System.out.printf("%s of %s \n", appliance.type, brandName);
    }
}
```



这样就将品牌和家用电器进行了分层，并各自实现具体对象，接下来通过调用组装我们需要的目标商品。

```java
// 调用，伪代码
IApplication washingMachine = new WashingMachine();
IApplication airConditioner = new AirConditioner();
IApplication sweepRobot = new SweepRobot();

AbstractBrand mideaWashingMachine = new MideaBrand(washingMachine);
AbstractBrand mideaAirConditioner = new MideaBrand(airConditioner);
AbstractBrand mideaSweepRobot = new MideaBrand(sweepRobot);

AbstractBrand haierWashingMachine = new HaierBrand(washingMachine);
AbstractBrand haierAirConditioner = new HaierBrand(airConditioner);
AbstractBrand haierSweepRobot = new HaierBrand(sweepRobot);

AbstractBrand greeAirConditioner = new GreeBrand(airConditioner);
AbstractBrand greeSweepRobot = new GreeBrand(sweepRobot);

mideaWashingMachine.description();
mideaAirConditioner.description();
mideaSweepRobot.description();

haierWashingMachine.description();
haierAirConditioner.description();
haierSweepRobot.description();

greeAirConditioner.description();
greeSweepRobot.description();

// output
// washing machine of Midea
// air conditioner of Midea
// sweep robot of Midea
// washing machine of Haier
// air conditioner of Haier
// sweep robot of Haier
// air conditioner of Gree
// sweep robot of Gree
```

由此可以看出，只要定义好了顶层的分层抽象逻辑，具体实现类就很容易进行横向扩展，再新增家用电器或者品牌都变得容易，但需要注意，如果实现类足够多，容易造成"类爆炸"。



### 4.6 组合模式（Composite ）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如一个对象拥有自己完整的属性和行为，它同时又是其他对象的组成部分，所以可以使用组合模式定义一个抽象层，该抽象层提供两个对象的行为，就可以通过抽象层对象来创建复杂的组合关系。比如，在OS的文件系统中，一个目录既可以包含多个目录，每个目录又可以包含多个文件。

> 题引：一个大公司通常在世界各地有自己的分公司，而不管总公司还是分公司都独自成体系，有自己的职能部门。现在有一个公司，它在北京、旧金山和伦敦都有自己的分公司，总公司职能部门包括：人事部、财务部和秘书办；北京分公司有IT部、测试部、人事部；旧金山和伦敦分公司有业务部、人事部和财务部。



```java
public abstract AbstractOrganize {
    private String name; // 公司名或部门名
    
    public String getName() {
        return name;
    }
    
    public void setName() {
        this.name = name;
    }
    // 提供的方法，如果公司和部门都需要实现则定义抽象方法，否则实现方法但不提供内容
    public void addDepartment(Department... depts) {
        throw new UnsupportedOperationException("abstrac not support");
    }
    
    public void removeDepartment(Department dept) {
        throw new UnsupportedOperationException("abstrac not support");
    }
    
    public void addCompany(Company... companies) {
        throw new UnsupportedOperationException("abstrac not support");
    }
    
    public boolean removeCompany(Company company) {
        throw new UnsupportedOperationException("abstrac not support");
    }
    
    public abstract void print();
}

class Company extends AbstractOrganize {
    private List<Department> deptList = new ArrayList<>();
    private List<Company> companyList = new ArrayList<>();
    
    public void addDepartment(Department... depts) {
        for (Department d : depts) {
            deptList.add(d);
        }
    }
    
    public boolean removeDepartment(Department dept) {
		return deptList.remove(dept);
    }
    
    public void addCompany(Company... companies) {
        for (Company c : companies) {
            companyList.add(c);
        }
    }
    
    public boolean removeCompany(Company company) {
		return companyList.remove(company);
    }
    
    @Override
    public void print() {
        deptList.forEach(System.out::println);
        companyList.forEach(System.out::println);
    }
    
    @Override
    public String toString() {
        // toString方法用于打印，省略
    }
}

class Department extends AbstractOrganize{
    
    @Override
    public void print() {
        System.out.println(name);
    }
}

// 测试，伪代码
AbstractOrganize headCompany = new Company();
AbstractOrganize pekingCompany = new Company();
AbstractOrganize sanFranciscoCompany = new Company();
AbstractOrganize londonCompany = new Company();
headCompany.addCompany(pekingCompany, sanFranciscoCompany, londonCompany);

AbstractOrganize personnelDept = new Department();
AbstractOrganize financeDept = new Department();
AbstractOrganize secretaryDept = new Department();
AbstractOrganize itDept = new Department();
AbstractOrganize testDept = new Department();
AbstractOrganize businessDept = new Department();

headCompany.addDepartment(personnelDept, financeDept, secretaryDept);
pekingCompany.addDepartment(itDept, testDept, personnelDept);
sanFranciscoCompany.addDepartment(businessDept, financeDept, personnelDept);
londonCompany.addDepartment(businessDept, financeDept, personnelDept);

headCompany.print();
```



### 4.7 亨元模式（Flyweight）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;亨元模式是指当系统中存在大量的相同对象时，可以通过共享技术，将相同的类共享给使用者，而非创建。比如围棋游戏中，黑白棋就是大量的重复对象，如果每个棋子都要创建对象，则会造成系统资源吃紧甚至OOM发生，所以如果采用共享技术，将一盘棋中的黑子和白子只创建一个对象，在其他落子位置复用对象则不会造成该问题。亨元模式大量的应用于”池“计数，比如线程池、数据连接池、缓存池等等。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;亨元模式的重点，是要**区分内部状态和外部状态**，所谓内部状态是指被亨元对象类（FlyWeightFactory）持有的内部控制管理对象，是亨元的具体实现类（ConcreteFlyWeight）；而外部状态是指随着外部状态的改变而发生变化的对象，是不可共享亨元类（UnSharedFlyWeight）；

> 题引：对于一局围棋游戏，共享的是围棋棋子的颜色，而不可共享的是棋子的落子位置。

{% asset_img designpattern8.png 设计模式 %}



定义亨元模式接口（FlyWeight -> IChess）及其实现类（ConcreteFlyWeight -> Piece），对于围棋来说，颜色是共享状态，位置是不共享状态。

```java
// 亨元接口——棋子
public interface IChess {
    void setColor(Color color);
    Color getColor();
    void position(Coordinate);
}

// 亨元实现类
class Piece implements IChess {
    private Color color;
    public Piece(Color color) {
        this.color = color;
    }
    
    @Override
    public void setColor (Color color) {
        this.color = color;
    }
    
    @Override
    public Color getColor() {
        return color;
    }
    
    public void position(Coordinate c) {
        System.out.printf("%s 落位（%d, %d）", color.getValue, c.getX(), c.getY());
    }
}

```

定义非共享对象(UnsharedFlyWeight -> Coordinate)

```java
class Coordinate {
    private int x;
    private int y;
    
    public Coordinate(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    public int getX() {
        return x;
    }
    
    public int getY() {
        return y;
    }
}
```

最后定义亨元模式的工厂类（FlyweightFactory -> ChessFactory），由工厂类控制和管理共享对象。

```java
public class ChessFactory {
    private static final Map<Color, IChess> pieces = new HashMap<>(); // 内部控制棋子创建
    
    private ChessFactory(){} // 私有构造器，工厂类是单例的
    
    // 静态内部类实现工厂单例对象
    private final class ChessFactoryInstanceHolder {
        private static final ChessFactory INSTANCE = new ChessFactory();
    }
    
    // 返回工厂单例
    public ChessFactory getInstance() {
        return ChessFactoryInstanceHolder.INSTANCE;
    }
    
    public IChess getPiece(Color color) {
        IChess piece = pieces.get(color);
        if (Objects.isNull(piece)) {
            piece = new Piece(color);
            pieces.put(color, piece);
        }
        return piece;
    }
    
    public int getSize() {
        return pieces.size();
    }
    
}
```

```java
// 测试，伪代码
// 黑子执子先行，模拟3步之内的操作
ChessFactory factory = ChessFacotry.getInstance();
IChess pieceBlack = factory.get(Color.BLACK);
pieceBlack.position(new Coordinate(5,5)); // step1:黑子先落子棋盘坐标（5,5）位置

IChess pieceWhite = facotry.get(Color.WHITE);
pieceWhite.position(new Coordinate(15.15)); // step2:白子随后落子（15,15）坐标位置

pieceBlack = factory.get(Color.BLACK);
pieceBlack.position(new Coordinate(13,4)); // step3:黑子落子（13,4）位置

System.out.println("当前棋子类型:" + factory.getSize());
// output
// 黑子落位（5,5）
// 白子落位（15,15）
// 黑子落位（13,4）
// 当前棋子类型: 2
```

