---
title: 多线程基础（二）
date: 2020-5-27
tags: [多线程, 线程池, 源码]
---
{% asset_img image1.jpg 多线程 %}

# 多线程基础（二）
<!--more-->



## 9 线程池及其源码

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在传统多线程创建中，用户通过Thread、Runnable或者Callable手动创建线程并执行，这样做会产生两个重要的问题：

1. 线程的创建和销毁是会造成系统资源消耗的，如果过度创建线程执行有可能造成“过度切换”问题。
2. 线程是重要资源，过度的创建不仅使执行效率降低，还容易引起内存消耗增加的问题，对于重要的大对象创建，通常采用“池”的概念来管理，达到线程复用的目的。



### 9.1 Executor

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executor是java.util.concurrent下的重要异步执行接口，它的继承关系如下：

{% asset_img executor.png executor %}



其定义了一个接收Runnable对象的方法executor，,该方法接收一个Runable实例，它用来执行一个任务，任务即一个实现了Runnable接口的类。

```java
public interface Executor {
    void execute(Runnable command);
}
```



### 9.2 ExecutorService

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecutorService是扩展子接口，提供了线程生命周期相关的方法。

```java
public interface ExecutorService extends Executor {
    void shutdown(); // 平滑关闭，收回线程池 
    boolean isShutdown(); //判断关闭
    // 提交线程，返回Future
    <T> Future<T> submit(Callable<T> task);
    Future<?> submit(Runnable task);
    ...
}
```

submit支持Callable和Runnable执行并返回Future对象，通过Future对象内的方法可以感知和获得执行结果。

```java
public interface Future<V> {
    // 中断任务运行
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    
    // 判断是否线程执行结束有返回结果
    boolean isDone();
    
    // 获得返回结果
    V get() throws InterruptedException, ExecutionException;
    // 带超时的返回结果
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

需要说明的是，如果使用get方法直接获取Future结果，调用线程将会阻塞，直到执行线程执行结束。可以使用isDone非阻塞式的监听执行情况并最后通过get获得结果。



### 9.3 Executors

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。主要包含以下几种类型：

1. `Executors.newCachedThreadPool();`，创建可以缓存的线程池，如果有空闲线程则进行复用，否则再未达到线程个数阈值时创建新的线程。常用于创建**生命周期短**的任务线程，如果空闲池中的线程超过空闲阈值（默认60s）则会被线程池关闭并清理。
2. `Executors.newFixedThreadPool(int);`，创建固定线程个数的线程池，原理基本与newCachedThreadPool类似，只不过在线程不足时不会再次创建线程（不存在空闲池概念），内部通过阻塞队列来管理调用线程。
3. `Executors.newScheduledThreadPool(int)；`，创建一个具有调度能力的线程池，其线程可以实现定时任务等，相比于Timer更加安全且功能丰富。
4. `Executors.SingleThreadExecutor()；`，创建一个单例线程，即任意时间线程池中只存在一个线程，按照任务提交顺序执行，调用之后即被销毁。

这些静态工厂方法虽然可以创建不同类型的线程池，但通过源码可以看到，都是调用ThreadPoolExecutor来构造目标线程池。

```java
public class Executors {

    // 非调度能力的都是通过ThreadPoolExecutor来构造目标线程池
	public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }  
    
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
    
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
    
    // 调度能力通过构造ScheduledThreadPoolExecutor构造
    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
        return new DelegatedScheduledExecutorService
            (new ScheduledThreadPoolExecutor(1));
    }
    
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
}
```





### 9.4 ThreadPoolExecutor

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在孤尽的《阿里巴巴Java开发手册》并发编程规约的第4条指出：“线程池不允许使用Executors创建，而是通过ThreadPoolExecutor的方式创建，这样的好处是，可以使开发人员更加明确线程池的运行规则，规避资源耗尽的风险”，从企业安全风险把控角度来看，这样的规约是严谨且可被接纳的，当然如果开发人员对原理“烂熟于心”，可以通过Executors快速创建线程池也未尝不可。

**构造器**

线程池在构建时需要注意以下参数：核心线程数corePoolSize、最大线程数maximumPoolSize、心跳周期keepAliveTime、心跳周期时间单位TimeUnit、维护线程调度的阻塞队列BlockingQueue\<Runnable>、线程工厂类ThreadFactory和拒绝策略RejectedExecutionHandler。

```java
// 构造函数
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler);
    
// 自定义参数构建线程池
BlockingQueue queue = new LinkedBlockQueue(10);

// 线程工厂
UserThreadFactory threadFactory = new ThreadFactory((task) -> {
    String threadName = getThreadName();
    Thread thread = new Thread(task,threadName);
    return thread;
});

// 自定义符合业务能力的拒绝策略
UserRejectHandler rejectHandler = new RejectedExecutionHandler((task, executor) -> {
    // 具体拒绝策略实现
});
// 或者使用提供的拒绝策略
RejectedExecutionHandler rejectHandler = new ThreadPoolExecutor.AbortPolicy();// 默认策略

// 核心线程数5、最大线程数20、心跳周期60s
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 20, 60, TimeUnit.SECONDS,
                                                  queue, threadFactory, rejectHandler );
```



**拒绝策略**

当不需要用户自定义拒绝策略时，可以使用ThreadPoolExecutor提供的拒绝策略：

1. ThreadPoolExecutor.AbortPolicy：默认策略，丢弃任务并抛出异常RejectedExecutionException。
2. ThreadPoolExecutor.DiscardPolicy：丢弃任务不抛出异常。
3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃等待队列中时间等待最长的任务，加入新任务。
4. ThreadPoolExecutor.CallerRunsPolicy：调用run方法时绕过线程池直接执行。



**阻塞队列**

阻塞队列是并发编程的重要数据结构，主要用于保存工作线程Worker，在后续详细介绍，此处列出常用阻塞队列实现对象：

1. LinkedBlockingQueue：单向FIFO，因为基于链表实现，所以在队列频繁出队、入队过程中效率高所以是最常用的阻塞队列，当不显式定义该队列对象容量时，默认大小为Integer.MAX_VALUE。
2. ArrayBlockingQueue：单向FIFO，基于数组实现的有界队列，由于出队、入队涉及数组移位所以效率不如阻塞队列，当大容量时会严重影响吞吐量。
3. PriorityBlockingQueue：基本数据结构同LinkedBlockingQueue，区别在于队列内部排序（即调度优先级）由比较器Comparator维护。
4. SynchronousQueue：同步队列，也是“生产者-消费者”模型队列，产生的队列元素入队之后需要被另一端消费出队从而完成一个周期。



**线程池对象状态属性**

```java
// 将整型32位ctl按位拆分，高3位用于表示线程池状态，低29位用于表示工作线程数
// 当线程数超过整型低29位可表示范围时，采用长整型AtomicLong代替
// 比如，高三位2进制可以表示0~7不同的值
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int COUNT_MASK = (1 << COUNT_BITS) - 1;

// runState is stored in the high-order bits
private static final int RUNNING    = -1 << COUNT_BITS; //
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;

// Packing and unpacking ctl
// 取反、与操作，获得当前线程池状态
private static int runStateOf(int c)     { return c & ~COUNT_MASK; }
// 与操作，获得工作线程数
private static int workerCountOf(int c)  { return c & COUNT_MASK; }
// 高3位和低29位或运算，合并成一个值
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

ctl高3位表示了线程池的运行状态，包括：

- RUNNING：运行状态，接收新任务，111；
- SHUTDOWN：关闭状态，不接收新任务但可以继续执行队列内已有任务，000；
- STOP：停止状态，拒接接收新任务并中断所有任务，001；
- TIDYING：整顿状态，表示所有任务已被终止，010；
- TERMINATED：结束状态，表示已清理完所有现场，011；



**execute方法**

execute方法是顶级接口Executor中唯一定义的方法，也是执行Runnable线程的方法。通过官方注释首先明确处理步骤：

1. 如果运行的线程少于corePoolSize，会将入参任务通过调用addWorker启动执行，当然addWorker会检查运行状态和数量从而通过返回false防止在不应该添加线程的情况下添加线程。
2. 当任务被添加进入工作队列，为了避免在第一次检查之后线程销毁或者线程池关闭，所以需要进行双重检查以确保进入工作队列，否则会执行拒绝策略。
3. 如果无法添加任务进入工作队列，那么就执行拒绝策略。

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    // 步骤1
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 步骤2
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 步骤3
    else if (!addWorker(command, false))
        reject(command);
}
```



**addWorker方法**

addWorker是线程池的重要方法，首先检查是否可以添加新任务，如果可以添加并最终添加成功会返回true；当线程池状态不为RUNNING或者县城创建失败会返回false。

> 特别说明：源码中用到了改进后的goto语句，关于goto语句争论很多，但需要说明的是虽然它弊端很多，但在多重循环中，恰当的使用可以快速跳过不必要的操作，节省时间提高效率，这也是为什么Java作为后起之秀依然没有彻底放弃的原因，反而进行了改进，我个人支持恰当的使用goto，虽然这样违反编码规约（微笑脸）。
>
> （源码中都使用了，我在工作中是不是也可以使用的挺直腰杆，理直气壮  [doge]）

```java
private final HashSet<Worker> workers = new HashSet<>(); // 工作线程容器
private final ReentrantLock mainLock = new ReentrantLock(); // 线程池主锁，敏感操作时使用

/**
 * @Param firstTask:外部启动线程时构造的第一个线程
 * @Param core:为true时表示新增工作线程，判断RUNNING状态下线程数是否达到corePollSize
 *			   为false时表示新增工作线程，判断RUNNING状态下线程是否少与maximumPoolSize
 */
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (int c = ctl.get();;) {
        // 判断运行状态是否为RUNNING
        if (runStateAtLeast(c, SHUTDOWN)
            && (runStateAtLeast(c, STOP)
                || firstTask != null
                || workQueue.isEmpty()))
            return false;

        for (;;) {
            // 最大线程数不能超过2^29，否则低29位无法保存线程
            if (workerCountOf(c)
                >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))
                return false;
            // CAS增加工作线程数
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get(); // 反复读取状态判断
            // 如果线程池SHUNTDOWN，跳转至retry标签执行
            if (runStateAtLeast(c, SHUTDOWN))
                continue retry;
        }
    }

    // 开始创建工作线程
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask); // 使用线程工厂创建线程并封装进Worker对象中
        final Thread t = w.thread;
        if (t != null) {
            // 敏感操作，持有线程池主锁，避免添加和启动时产生并发
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int c = ctl.get();

                // 当属于RUNNING状态或者STOP状态下firstTask为空，说明需要添加工作线程
                if (isRunning(c) || (runStateLessThan(c, STOP) && firstTask == null)) {
                    if (t.isAlive()) // 如果添加工作线程时，该线程已经被创建则抛出异常
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    // 设定线程池最大并发个数
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock(); // 新增完毕，解锁
            }
            // 工作线程添加成功，启动线程
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```



最后，总结一下使用线程池的注意点：

- 必须通过线程池创建和调用线程，不能自定义线程执行，方便维护和管理。

- 根据实际业务场景使用ThreadPoolExecutor构建线程池。

- 对每个线程应该赋名，方便jstack分析。




### 9.5 线程异常捕获

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在子线程中抛出的异常是无法被主线程探知的，需要通过UncaughtExceptionHandler线程异常处理接口来捕获异常并进行处理。

```java
public class Test {

    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            // 主动抛出异常
            throw new RuntimeException("sub Thread excute error");
        }, "subThread");
        // 线程启动前设置异常捕获器
        t.setUncaughtExceptionHandler(new DefinedUncaughtExceptionHandler());
        t.start();

        try {
            TimeUnit.SECONDS.sleep(1); // 主线程sleep 1s
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("main thread over");
    }

    // 自定义线程异常捕获器
    private static class DefinedUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
        @Override
        public void uncaughtException(Thread t, Throwable e) {
            System.out.println(t.getName() + " find Exception：" + e.getMessage());
        }
    }

}
```

