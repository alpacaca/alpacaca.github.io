---
title: 设计模式（四）
date: 2020-6-20
tags: [设计模式]
---
{% asset_img image1.jpg 设计模式 %}

# 设计模式（四）
<!--more-->

## 4 行为型设计模式

- 策略模式、模版模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

### 4.1 迭代器模式

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;迭代器模式提供顺序访问聚合对象内的各个元素，并且不会暴露内部状态。在JDK的集合中，几乎每个集合都继承了Iterator接口并通过内部类形式提供了迭代器用于顺序访问集合内的各个元素，下面以ArrayList和LinkedList展示迭代器模式

 ```JAVA
// ArrayList迭代器模式的部分实现
// 主要通过索引代表来确定数据在数组中的位置
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    // 提供迭代器对象
    public Iterator<E> iterator() {
        return new Itr();
    }
    
    // 迭代器实现类
    private class Itr implements Iterator<E> {
        int cursor;       
        int lastRet = -1; 
        int expectedModCount = modCount;

        Itr() {}

        public boolean hasNext() {
            return cursor != size;
        }

        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }
    }
}
 ```

```java
// LinkedList迭代器部分实现
// 主要通过next后继指针来确定链表中数据的位置
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
{
    // 提供迭代器对象
    public ListIterator<E> listIterator(int index) {
        checkPositionIndex(index);
        return new ListItr(index);
    }
    
    // 迭代器实现类
    private class ListItr implements ListIterator<E> {
        private Node<E> next;
        private int nextIndex;

        ListItr(int index) {
            next = (index == size) ? null : node(index);
            nextIndex = index;
        }

        public boolean hasNext() {
            return nextIndex < size;
        }

        public E next() {
            checkForComodification();
            if (!hasNext())
                throw new NoSuchElementException();

            lastReturned = next;
            next = next.next;
            nextIndex++;
            return lastReturned.item;
        }
    }
}
```



### 4.2 观察者模式

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当多个对象之间存在一对多的关系，修改一个对象会影响被依赖的对象发生变化，通过观察者模式可以自动通知该对象并更新。观察者模式中的对象需要建立一套触发机制进行自动修改，当对象之间存在循环依赖的话，可能触发循环更新，发生严重的占用系统资源导致崩溃。观察者模式一般通过会定义两个抽象对象进行解耦操作，并由具体实现类完成。可概括为如下：

1. Subject抽象类，通过集合形式持有注册的观察者，并在数据更新后通知所有注册的观察者进行数据更新。
2. Observer抽象类，通常定义收到Subject通知后执行数据更新操作。

所以，观察者模式通常完成与**“订阅-下发”**功能相关的业务。

{% asset_img designpattern1.png 设计模式 %}



> 题引：拍卖行进行商品拍卖，每一件商品都有多个竞争者竞价，每次竞价都会被拍卖人员广播给所有竞争者，从而进行新一轮的竞价，依次往复，直到商品被卖出。



{% asset_img designpattern2.png 设计模式 %}



首先定义抽象层，分别是针对拍卖者、观察者和竞价接口。

```java
// 定义Subject的拍卖对象
public interface IAuction {
    void registerObserver(IBidderObserver observer) ; // 注册观察者
    void removeObserver(IBidderObserver observer) ; // 删除观察者
    void notifyObserver(double price); // 广播观察者
    void receivePrice(IBidderObserver bidder, double price); // 收到竞价
    String win(); // 获胜者
    int getSize(); // 竞争人数
}

// 定义Observer的竞价者观察对象
public interface IBidderObserver {
    void update(double price);
    int getNumber();
}

// 额外定义一个竞价者相关的行为接口
public interface IBid {
    void participate(IAuction auction); // 参与
    void bid(IAuction auction, double price); // 喊价
    void quit(IAuction auction); // 推出竞价
}
```

定义具体的观察者对象，即竞争者。

```java
class Bidder implements IBidderObserver, IBid {
    private int number; // 编号
    private double bidPrice; // 竞价
    private double currentPrice; // 当前商品价格

    public Bidder(int number) {
        this.number = number;
    }

    @Override
    public void update(double price) {
        currentPrice = price;
    }

    @Override
    public void participate(IAuction auction) {
        auction.registerObserver(this);
    }

    @Override
    public void bid(IAuction auction, double price) {
        bidPrice = price;
        auction.receivePrice(this, bidPrice);
    }

    @Override
    public void quit(IAuction auction) {
        auction.removeObserver(this);
    }

    @Override
    public int getNumber() {
        return number;
    }
}
```

接下来定义拍卖者的实现类。

```java
class Auction implements IAuction {
    private List<IBidderObserver> bidders = new ArrayList<>(); // 观察者列表
    private static IBidderObserver bestBidder; // 当前竞价最高者
    private static volatile String name; // 本次拍卖物品名称
    private static volatile double price; // 本次拍卖价格

    // 初始拍卖物品价格
    public Auction(String name, double price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public void registerObserver(IBidderObserver observer) {
        if (!bidders.contains(observer)) {
            bidders.add(observer);
        }
    }

    @Override
    public void removeObserver(IBidderObserver observer) {
        if (bidders.contains(observer)) {
            bidders.remove(observer);
        }
    }

    @Override
    public void notifyObserver(double price) {
        for (IBidderObserver bidder : bidders) {
            bidder.update(price);
        }
    }

    // 收到价格
    public void receivePrice(IBidderObserver bidder, double price) {
        if (bidders.contains(bidder) && this.price < price) {
            this.price = price;
            bestBidder = bidder;
            notifyObserver(price);
        }
    }

    // 获胜者
    @Override
    public String win() {
        return String.format("%d 号参与者赢得 %s , 总价: %.2f ",
                             bestBidder.getNumber(), name, price);
    }

    @Override
    public int getSize() {
        return bidders.size();
    }
}
```

测试代码，模拟一轮拍卖。

```java
IBid bidder1 = new Bidder(1); // 1号竞争者
IBid bidder2 = new Bidder(2); // 2号竞争者
IBid bidder3 = new Bidder(3); // 3号竞争者
IBid bidder4 = new Bidder(4); // 4号竞争者

// 初始商品名称和价格
String name = "兽首";
double price = 10000.0;
IAuction auction = new Auction(name, price);
// 竞争者参与竞价
bidder1.participate(auction);
bidder2.participate(auction);
bidder3.participate(auction);
bidder4.participate(auction);

// 第一轮竞价
bidder1.bid(auction, price + 5000.0);
bidder2.bid(auction, price + 8000.0);
bidder3.quit(auction); // 3号退出本次竞价
bidder4.bid(auction, price + 6000.0);
System.out.println("竞争人数: " + auction.getSize());
System.out.println(auction.win());

// output
// 竞争人数: 3
// 2 号参与者赢得 兽首 , 总价: 18000.00 
```



### 4.3 模板模式

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一个抽象类（模板）定义了一个骨架，骨架中实现了部分的功能，还有一部分功能为抽象方法，由具体的继承类来完成，也就是说，利用多态的特性，把更具体的实现延迟到子类中。



> 题引：在通用的做菜过程中，一般可以分为洗菜、摘菜、烹制、装盘这四个大步骤，无论做什么样式的菜品，其中洗菜和摘菜是通用的，而口味体现在不同的烹制方法上，不同的装盘也会呈现不同的外观。通过模板模式创建糖醋类做法、宫保类做法和红烧类做法。



{% asset_img designpattern3.png 设计模式 %}



首先创建模板类，该类定义了四个做菜步骤，其中洗菜和摘菜是统一通用步骤，烹制和装盘需要具体子类实现重写，最后定义做菜标准流程`cookDish`做出一道别具特色的菜品。

```java
public abstract class Cuisine {
    private final String name; // 菜品名称
    
    public Cuisine(String name) {
        this.name = name;
    }
    
    public final void wash() {
        System.out.println("洗菜");
    }
    
    public final void trim() {
        System.out.println("择菜");
    }
    
    public abstract void cook(); // 由具体子类实现烹制方式
    
    public abstract void dishup(); // 由具体子类实现装盘
    
    // 定义做菜工艺流程
    public void cookDish() {
        wash();
        trim();
        cook();
        dishup();
        System.out.println(name + " 呈现在眼前。");
    }
}
```

定义具体实现类，包括糖醋类、宫保类、红烧类。

```java
// 宫保类
class Kungpao extends Cuisine {
    public Kungpao(String name) {
        super(name);
    }
    
    @Override
    public void cook() {
        System.out.println("宫保烹制");
    }
    
    @Override
    public void dishup() {
        System.out.println("装盘后撒上香葱");
    }
}

// 糖醋类
class SweetSour extends Cuisine {
    public SweetSour(String name) {
        super(name);
    }
    
    @Override
    public void cook() {
        System.out.println("糖醋烹制");
    }
    
    @Override
    public void dishup() {
        System.out.println("装盘后淋上汤汁");
    }
}

// 红烧类
class Braise extends Cuisine {
    public Braise(String name) {
        super(name);
    }
    
    @Override
    public void cook() {
        System.out.println("红烧烹制");
    }
    
    @Override
    public void dishup() {
        System.out.println("装盘后撒上香葱");
    }
}
```

最后伪代码测试。

```java
Cuisine kungpao = new Kungpao("宫保鸡丁");
kungpao.cookDish();

Cuisine sweetSour = new SweetSour("糖醋里脊");
sweetSour.cookDish();

Cuisine braise = new Braise("红烧肉");
braise.cookDish();

// output
/*
洗菜
择菜
宫保烹制
装盘后撒上香葱
宫保鸡丁 呈现在眼前。

洗菜
择菜
糖醋烹制
装盘后淋上汤汁
糖醋里脊 呈现在眼前。

洗菜
择菜
红烧烹制
装盘后撒上香葱
红烧肉 呈现在眼前。
*/
```



### 4.4 策略模式

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;策略模式可以按照不同种类的策略执行同一个动作，并且切换策略不会影响执行，还可以根据不同场景提供不同的行为。策略模式遵循开闭原则，场景的切换可以切换适配的策略，可以通过创建新的策略接入新需求。策略模式通常用于替换圈复杂度高的条件分支。

> 题引：作为一名人民警察，当路边遇到年岁古稀的老人求助可以温柔和蔼的问询；当遇到袭击市民的暴徒，可以严词威震的呵斥；当遇到警署上级，可以谦逊的回应。遇见不同的人可以采用不同的交流方式。



{% asset_img designpattern4.png 设计模式 %}



首先定义一个交流沟通的策略接口，只有一种交流方法。

```java
public interface ICommunicationStrategy {
    String communicate();
}

```

定义交流的具体策略类。

```java
// 温柔的交流
class GentleCommunication implements ICommunicationStrategy {
    @Override
    public String communicate() {
        return "温柔的沟通";
    }
}

// 充满威严的交流
class AugustCommunication implements ICommunicationStrategy {
    @Override
    public String communicate() {
        return "呵斥";
    }
}

// 谦逊的交流
class ModestCommunication implements ICommunicationStrategy {
    @Override
    public String communicate() {
        return "谦逊的交流";
    }
}
```

定义具体的交流场景类。

```java
class StrategyContext {
    private ICommunicationStrategy strategy;
    
    public StrategyContext(ICommunicationStrategy strategy) {
        this.strategy = strategy;
    }
    
    // 更换策略
    public void changeStrategy(ICommunicationStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void communicate(String name) {
        System.out.prinf("与 %s %s \n", name, strategy.communicate());
    }
}
```

```java
// 测试，伪代码
ICommunicationStrategy strategy = new GentleCommunication();
StrategyContext context = new StrategyContext(strategy);
context.communicate("年逾古稀的老者");

strategy = new AugustCommunication();
context.changeStrategy(strategy); // 修改策略
context.communicate("暴徒");

strategy = new ModestCommunication();
context.changeStrategy(strategy); // 修改策略
context.communicate("上级领导");

// output
// 与 年逾古稀的老者 温柔的沟通
// 与 暴徒 呵斥
// 与 上级领导 谦逊的交流
```

策略模式的使用场景类通常需要确切的知道每个具体策略实现类，当业务不断膨胀可能造成策略类的类爆炸问题，所以最优的策略模式可以采用**枚举策略模式**，灵活的利用枚举对象的特性，通过实现接口来为不同的枚举对象提供更具体的实现策略，更容易切换策略且更容易理解并且不会产生庞大的实现类体积。

```java
public interface ICommunicationStrategy {
    String communicate();
}

public enum StrategyType implements ICommunicationStrategy{
    GENTLE {
        @Override
        public String communicate() {
            return "温柔的沟通";
        }
    },
    
    AUGUST {
        @Override
        public String communicate() {
            return "呵斥";
        }
    },
    
    MODEST {
        @Override
        public String communicate() {
            return "谦逊的交流";
        }
    }
}

class StrategyContext {
    private StrategyType strategy;
    
    public StrategyContext(StrategyType strategy) {
        this.strategy = strategy;
    }
    
    // 更换策略
    public void changeStrategy(StrategyType strategy) {
        this.strategy = strategy;
    }
    
    public void communicate(String name) {
        System.out.prinf("与 %s %s \n", name, strategy.communicate());
    }
}

// 测试，伪代码
StrategyContext context = new StrategyContext(StrategyType.GENTLE); // 初始策略
context.communicate("年逾古稀的老者");

context.changeStrategy(StrategyType.AUGUST); // 修改策略
context.communicate("暴徒");

context.changeStrategy(StrategyType.MODEST); // 修改策略
context.communicate("上级领导");

// output
// 与 年逾古稀的老者 温柔的沟通
// 与 暴徒 呵斥
// 与 上级领导 谦逊的交流
```



### 4.5 责任链模式

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;责任链模式，顾名思义，就是创建一个引用链，当引用链中的某个对象可以处理输入信息时就会执行相应的方法，否则就传递给下一个对象。在开发过程中对于日志系统定义了四个等级INFO、WARN、ERROR、DEBUG，每个日志等级有专门的处理对象，只有符合当前处理对象的日志等级才会被写入日志文件中。

> 题引： 在XX公司考勤系统中，个人请假时长小于3天则由PM统一处理，如果请假时间大于3天小于15天则由部长审批，如果超过15天则必须由人事总裁审批。



{% asset_img designpattern5.png 设计模式 %}



首先定义审批人的抽象类，提供责任链中的继任者，如果当前对象无法审批则交由继任者处理。

```java
public abstract AbstractApprover {
    private AbstractApprover successor;
    
    public AbstractApprover() {}
    
    public AbstractApprover(AbstractApprover successor) {
        this.successor = successor;
    }
    
    // 设置继任者
    protected void setSuccessor(AbstractApprover successor) {
        this.successor = successor;
    }
    
    // 审批
    protected abstract void approve(int duration);
}
```

接着定义责任链中具体的处理对象。

```java
// PM 处理3天以内的请假
class ProjectManager {
    public ProjectManager(AbstractApprover successor) {
        super(successor);
    }
    
    protected void approve(int duration) {
        if (duration > 0 && duration <= 3) {
            System.out.println("PM confirmed");
            return;
        }
        successor.approve(duration);
    }
}

// 部长 处理3-15天的请假
class Minister {
    public Minister(AbstractApprover successor) {
        super(successor);
    }
    
    protected void approve(int duration) {
        if (duration > 3 && duration <= 15) {
            System.out.println("Minister confirmed");
            return;
        }
        successor.approve(duration);
    }
}

// 人事总裁 处理3-15天的请假
class CHO {
    protected void approve(int duration) {
        if (duration > 15) {
            System.out.println("CHO confirmed");
            return;
        }
    }
}
```

```java
// 测试，伪代码
AbstractApprover cho = new CHO();
AbstractApprover minister = new Minister(cho);
AbstractApprover pm = new ProjectManager(minister);
AbstractApprover approveChain = pm; // 责任链从pm开始，cho结束

approveChain.approve(2);
approveChain.approve(10);
approveChain.approve(45);

// output
// PM confirmed
// Minister confirmed
// CHO confirmed
```

