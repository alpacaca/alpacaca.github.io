---
title: 多线程基础（三）
date: 2020-5-27
tags: [多线程, AQS, JUC, 协程, 纤程]
---
{% asset_img image1.jpg 多线程 %}

# 多线程基础（三）
<!--more-->



## 10 AQS和JUC简介

### 10.1 AQS

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstracQueuedSynchronizer类（简称AQS）是一个用于构建锁和同步器的抽象类，JUC中的很多同步器实现就是以AQS为基础创建而来。它解决了在实现同步器时涉及的大量细节问题，比如等待队列使用FIFO、获取操作和释放操作等。基于AQS构建的同步器不仅极大地减少了实现工作，而且也不必处理竞争问题，它只能在一个时刻发生阻塞，从而降低上下文切换开销，提高吞吐量。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AQS还提供管理同步器中的状态，该状态是一个整型值，可以又具体的实现器赋予状态的含义：比如ReentrantLock中用状态表示线程获取锁的次数，比如Semaphore表示剩余信号量，比如FutureTask表示任务状态等。该状态是volatile的，可以通过getState()、setState()和compareAndSetState()进行操作。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AQS定义了两种资源共享方式，即：Exclusive独占方式，如ReentranLock和Share共享方式如JUC中的Semaphore、CountDownLatch等，不同的同步器实现采用的资源共享方式不同。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AQS内部采用CLH队列实现阻塞队列，CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，即没有队列实体，而是通过定义内部类Node节点来实现锁的分配。



**AQS获取和释放**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=red>当有新的线程需要竞争资源，首先通过获取state的方式竞争，如果成功持有状态则直接调用线程方法；如果持有失败则进入CLH双向队列末尾等待。</font>AQS采用**模板方法设计模式**，在抽象类中提供 aquire() 方法执行该过程，而首次尝试获得state的 tryAcquire() 方法则交给具体实现的同步器。

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&	// 尝试获得state,获得成功返回true，否则返回false
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 没有获得state，则进入阻塞队列末尾并再次获得锁
        selfInterrupt(); // 最终没有获得锁，中断当前线程，等待阻塞队列的调度
}

// 交由具体同步器的实现类完成
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}

private Node addWaiter(Node mode) {
    Node node = new Node(mode);

    for (;;) {
        Node oldTail = tail;
        if (oldTail != null) {
            node.setPrevRelaxed(oldTail);
            if (compareAndSetTail(oldTail, node)) { // 将当前节点假如CLH队列末尾
                oldTail.next = node;
                return node;
            }
        } else {
            initializeSyncQueue();
        }
    }
}
```

接下来可以看看ReentranLock的非公平锁和Semaphore是如何实现 tryAcquire() 方法的：

```java
/* ReentranLock */
// Sync extends AbstractQueuedSynchronizer
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}

@ReservedStackAccess
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) { // CAS设置state状态
            setExclusiveOwnerThread(current); // 如果成功，则将当前线程设为互斥锁
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}

/* Semaphore */
public boolean tryAcquire() {
    return sync.nonfairTryAcquireShared(1) >= 0;
}

final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        int available = getState();
        int remaining = available - acquires;
        if (remaining < 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}
```



**自定义同步器的实现**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义实现一个锁，该锁内部维护一个私有的同步器对象，*锁的实现是简写，主要体现同步器的实现*。

```java
public class DefinedLock implements Lock {

    private final Synchronizer sync;

    public DefinedLock() {
        sync = new Synchronizer();
    }
    
    // lock和unlock属于简写，这里只为强调自定义同步器
    // state = 1表示获得，0释放。
    @Override
    public void lock() {
        sync.acquire(1); 
    }

    @Override
    public void unlock() {
        sync.release(0);
    }

    // Lock接口其他实现方法，省略
    
    // 推荐使用内部同步器对象
    private class Synchronizer extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            boolean flag = false;
            if (compareAndSetState(0, arg)) { // CAS给state赋值
                setExclusiveOwnerThread(Thread.currentThread()); // 当前线设置为独占锁
                flag = true;
            }
            return flag;
        }

        @Override
        protected boolean tryRelease(int arg) {
            if (isHeldExclusively()) { // 判断当前线程是否是独占锁的线程
                setState(arg);
                setExclusiveOwnerThread(null);
            }
            return false;
        }

        @Override
        protected boolean isHeldExclusively() {
            return getExclusiveOwnerThread() == Thread.currentThread();
        }
    }
}
```



### 10.2 JUC

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JUC（java.util.concurrent）指的是jdk5之后官方提供的同步包，其中包含了众多实际开发中用到的概念，包括：

- 锁Lock及其实现类；
- AQS及其衍生实现；
- 原子特性对象如AtomicInteger、AtomicLong等；
- 并发集合如ConcurrentHashMap等(同步集合)、CopyOnWriteList等(COW集合)；
- 线程池Executor及其实现类ThreadPoolExecutor、ExecutorService等。
- 阻塞队列BlockingQueue及其实现类。

可以说JUC是现代多线程并发开发的集大成者，前文已经陆续介绍了JUC的相关组件（锁、原子特性、线程池、AQS、<font color=red>并发集合跳转“源码标签”或"Java源码系列收看"</font>）。接下来最后<font color=blue>简要介绍</font>常用的并发器工具类：**CountDownLatch、Semaphore、CyclicBarrier**



#### 10.2.1 CountDownLatch

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（官方解释）允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CountDownLatch是一个基于执行时间的同步类，其中通过维护一个全局的 count 变量计数，其操作都具有原子性，主要通过 countDown() 和 await() 两个方法实现。

> 从字面意思理解，CountDown就是整数自减，直到count=0，Latch就是门闩的意思，意味着count=0时上闩关门。
>
> CountDownLatch是一次性使用的，当count=0时，对象即不可复用，需要重新创建。

使用CountDownLatch的await方法可以保证多个不同步线程最终可以统一回归到一个时间点继续向下执行。

```java
public class CountDownLatchDemo {
    private static final Random random = new Random();

    public static void main(String[] args) throws InterruptedException {
        // 初始计数10
        CountDownLatch countDownLatch = new CountDownLatch(10);
       
        // 创建10个线程，每个线程执行完毕，计数器自减
        for (int i = 1; i <= 10; i++) {
            new Thread(() -> {
                try {
                    TimeUnit.SECONDS.sleep(random.nextInt(5)); // 每个线程休眠随机时间秒
                    System.out.println(Thread.currentThread().getName() + " execute done");
                    countDownLatch.countDown();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Thread-" + i).start();
        }
        // 等待count=0，即10个线程执行完毕，此时主线程阻塞
        countDownLatch.await();

        // 主线程阻塞结束，所有线程都执行完毕，开始继续执行主线程
        System.out.println("count = " + countDownLatch.getCount());
        System.out.println("main thread end");
    }
}

/*
 * output:
Thread-8 execute done
Thread-4 execute done
Thread-6 execute done
Thread-5 execute done
Thread-1 execute done
Thread-2 execute done
Thread-3 execute done
Thread-10 execute done
Thread-7 execute done
Thread-9 execute done
count = 0
main thread end
 */
```



#### 10.2.2 Semaphore

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（官方解释）Semaphore用于限制可以访问某些资源（物理或逻辑的）的线程数目，他维护了一个许可证集合，有多少资源需要限制就维护多少许可证集合。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之，Semaphore可以控制线程的并发数量，它初始化定义一个信号量上限，通过调用 acquire() 方法获得令牌和 release() 释放令牌。内部通过维护一个整型的 state 状态来表示信号量（即可用令牌个数），acquire()时会判断state，从而确定是获取令牌亦或阻塞等待获取令牌，获取成功state自减。release()时会将state自增，并从阻塞队列全部唤醒等待线程竞争获得令牌，重复acquire过程，这其中都是通过CAS修改state计数。

```java
public class SemaphoreDemo {

    private static final Random random = new Random();
    private static final int SEMAPHORE_PERMIT = 3;

    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(SEMAPHORE_PERMIT);
        final Semaphore tmpSemaphore = semaphore;
		// 创建10个线程依次获取令牌，执行完毕释放令牌
        for (int i = 1; i <= 10; i++) {
            new Thread(() -> {
                try {
                    tmpSemaphore.acquire(); // 获取令牌
                    // 打印当前可用令牌数和阻塞线程个数
                    System.out.printf("current token count: %d, wait queue count: %d",
                         tmpSemaphore.availablePermits(), tmpSemaphore.getQueueLength());
                    
                    TimeUnit.SECONDS.sleep(random.nextInt(5)); // 每个线程休眠随机时间秒
                    System.out.println(Thread.currentThread().getName() + " execute done");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    tmpSemaphore.release(); // 释放令牌
                }
            }, "Thread-" + i).start();
        }

        System.out.println("main thread done");

        // 使用完毕，销毁信号量对象
        while (semaphore.getQueueLength() == 0 
               && semaphore.availablePermits() == SEMAPHORE_PERMIT) {
            semaphore = null;
        }
    }
}

/*
 * output:
current token count: 0, wait queue count: 0
current token count: 0, wait queue count: 0
current token count: 0, wait queue count: 0
main thread done
Thread-5 execute done
current token count: 0, wait queue count: 6
Thread-2 execute done
current token count: 0, wait queue count: 5
Thread-4 execute done
Thread-3 execute done
current token count: 0, wait queue count: 4
current token count: 0, wait queue count: 3
Thread-10 execute done
current token count: 0, wait queue count: 2
Thread-8 execute done
current token count: 0, wait queue count: 1
Thread-7 execute done
Thread-9 execute done
current token count: 1, wait queue count: 0
Thread-6 execute done
Thread-1 execute done
 */
```



Semaphore和CountDownLatch都属于信号量类型工具，并且初始化时都规定了信号量上限h，两者的区别在于：

1. Semaphore内部维护state表示可用令牌个数，从0开始增长到h；CountDownLatch内部维护计数器count，从h递减到0结束。
2. Semaphore通过acquire获得令牌state-1，通过release释放令牌state+1，state是可变化的；CountDownLatch通过countDown实现count递减直到为0；
3. Semaphore可复用，CountDownLatch不可复用，再次使用需要重新创建对象。
4. CountDownLatch可以通过阻塞保证多个线程最终回归同一时间点并继续向下执行，Semaphore不可以。



#### 10.2.3 CyclicBarrier

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（官方解释）允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为*循环* ，因为它可以在等待的线程被释放之后重新使用。

简而言之，就是会让所有线程都等待完成后才会继续下一步行动。线程通过调用 await() 方法表示当前线程已经到达“集合点”位置，进入阻塞，直到所有线程都到达“结合点”位置后，继续各自执行。

```java
public class CyclicBarrierDemo {
    private static final Random random = new Random();

    public static void main(String[] args) {
        // CyclicBarrier初始化集合数量，并允许设置集合后的动作
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3, () -> {
            System.out.println("arrive the safe point together");
        });

        // 创建3个线程，每个线程依次执行，通过调用await()阻塞等待其他线程集合后方可继续执行
        for (int i = 1; i <= 3; i++) {
            new Thread(() -> {
                try {
                    // 第一次执行和等待集合
                    TimeUnit.SECONDS.sleep(random.nextInt(5));
                    System.out.println(Thread.currentThread().getName() + " arrival");
                    cyclicBarrier.await(); // 等待其他线程到达集合点

                    // 第二次执行和等待集合
                    TimeUnit.SECONDS.sleep(random.nextInt(5));
                    System.out.println(Thread.currentThread().getName() + " next arrival");
                    cyclicBarrier.await();

                    // 最后一次执行和等待集合
                    TimeUnit.SECONDS.sleep(random.nextInt(5));
                    System.out.println(Thread.currentThread().getName() + " finished");
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }, "Thread-" + i).start();
        }
    }
}

/*
 * output:
Thread-3 arrival 
Thread-1 arrival
Thread-2 arrival
arrive the safe point together
Thread-2 next arrival
Thread-3 next arrival
Thread-1 next arrival
arrive the safe point together
Thread-2 finished
Thread-3 finished
Thread-1 finished
arrive the safe point together
 */
```



CyclicBarrier 与 CountDownLatch 区别：

1. CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的。

2. CountDownLatch 参与的线程的职责是不一样的，各自执行结束之后，最终回归初始线程（主线程）。CyclicBarrier 参与的线程职责是一样的。

   

## 11 阻塞队列

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockingQueue即阻塞队列，基于ReentrantLock实现线程安全。他是“生产者-消费者”模型的主要调度容器。最为基础接口它实现类如下图所示：

{% asset_img blockingqueue.png blockingqueue %}

- ArrayBlockingQueue：是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。支持公平锁和非公平锁。
- LinkedBlockingQueue：一个由链表结构组成的有界队列，此队列的长度为Integer.MAX_VALUE。
- PriorityBlockingQueue： 一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。
- DelayQueue： 基于PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。
- SynchronousQueue： 不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。是一种单线程模型的阻塞队列。
- LinkedBlockingDeque： 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半。



**阻塞队列的方法**

|          | 异常反馈 | null反馈 | 阻塞   | 超时    |
| -------- | -------- | -------- | ------ | ------- |
| 压入     | add()    | offer()  | put()  | offer() |
| 弹出     | remove() | poll()   | take() | poll()  |
| 队首元素 | element  | peek     |        |         |



**生产者消费者简单实现**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生产者-消费者是经典的同步模型，包含：多生产多消费、多生产单消费、单生产多消费和单生产单消费。以下以单生产多消费介绍。

```java
public class ProducerAndConsumerDemo {

    private static final BlockingQueue<String> queue = new LinkedBlockingQueue<>();

    private static final int INVENTORY = 50;

    public static void main(String[] args) {
        new Thread(new Producer()).start();
        new Thread(new Consumer(), "Consumer1").start();
        new Thread(new Consumer(), "Consumer2").start();
    }

    // 生产者对象
    private static class Producer implements Runnable {
        @Override
        public void run() {
            int count = 1;
            while (queue.size() < INVENTORY) {
                try {
                    TimeUnit.MILLISECONDS.sleep(500);
                    String goods = "goods-" + count++;
                    queue.put(goods);
                    System.out.printf("produce %s \n", goods);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("# Produce over #");
        }
    }

    // 消费者对象
    private static class Consumer implements Runnable {
        @Override
        public void run() {
            while (true) {
                try {
                    TimeUnit.SECONDS.sleep(2);
                    System.out.printf("%s consume %s \n", Thread.currentThread().getName(), queue.take());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
/*
 * output
produce goods-1 
produce goods-2 
produce goods-3 
Consumer1 consume goods-1 
Consumer2 consume goods-2 
produce goods-4 
produce goods-5 
produce goods-6 
produce goods-7 
Consumer1 consume goods-3 
Consumer2 consume goods-4 
produce goods-8 
produce goods-9 
produce goods-10 
produce goods-11 
Consumer1 consume goods-5 
Consumer2 consume goods-6
...
 */
```



## 12 协程和纤程

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中的线程是一种系统级线程，它运行在用户态（User），从用户态通过JVM调起内核态的线程运行，这其中每个线程的创建，以及在用户态和内核态的状态切换开销都是会消耗可观资源的，为了节省资源开销Java采用线程池的方式管理有限的线程资源。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协程（Coroutine），是一种轻量级的线程(lightweight thread)，它只存在于用户态，一个线程可以包含多个协程，目前在GO语言中广泛使用，通过`go`关键字就可以创建一个协程，它的工作原理是：**协程负责执行线程中的一段代码片段，当需要切换协程时，会将当前协程执行的上下文进行保存，同时让出CPU资源，恢复被调用协程的上下文继续执行**。与线程最大的区别在于：**协程只工作在用户态，减少了和内核态切换的开销；线程由系统调度器执行，抢占式调度策略难以控制线程的有序调用，协程可以完全依赖开发者控制调用。**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Windows平台运行或者由微软命名的协程称为纤程（Fiber），从2018年开始，由OpenJDK主导的Loom项目旨在从JVM层面实现协程，但作为程序语言的“老者”，考虑到众多程序的稳定，Java想要在协程上做出突破是比较困难的，但作为未来并发编程的主导者，协程的上岸只是时间问题（Java的很多问题都是时间问题）。目前Java生态中三方库形式的协程支持可以看Quasar 项目，JVM层面的协程实现可以关注AJDK（Alibaba JDK）、作为JVM语言的佼佼者，Kotlin也通过编译器和类库提供支持。

作为Java宣传的保留项目，Oracle这一次喊出了：**“Code like sync，Work like async。”**

总结：

使用协程的优点：

1. 完全由应用程序控制。
2. 运行在用户态，减少与内核态转换的系统开销。
3. 基于上下文切换协程，转换速度快。
4. 因为协程调度可控，所以更符合人类语义且避免了线程安全。

协程的缺点：

1. 因为在线程中创建和运行，无法充分利用多核CPU能力，即CPU密集型。
2. 协程的阻塞必将导致所属线程的阻塞。