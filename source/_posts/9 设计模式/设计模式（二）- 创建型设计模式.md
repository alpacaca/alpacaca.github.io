---
title: 设计模式（二）
date: 2020-6-8
tags: [设计模式]
---
{% asset_img image1.jpg 设计模式 %}

# 设计模式（二）
<!--more-->

## 3 创建型设计模式

- 工厂模式、抽象工厂模式、单例模式、原型模式、建造者模式

### 3.1 静态工厂方法（Static Factory）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;严格来说，静态工厂方法并不属于设计模式，因为其严重破坏了OCP原则。静态工厂方法常用if...else if或者switch来完成。

> 题引：通过静态工厂创建不同风格的咖啡。

{% asset_img designpattern1.png 设计模式 %}

```java
public interface ICoffee {}
class Americano implements ICoffee{}
class Espresso implements ICoffee{}
class Latte implements ICoffee{}
class Cappucino implements ICoffee{}

enum CoffeeType {
    Americano, Espresso, Latte, Cappucino
}

public class CoffeeStaticFactory {
    
    public static ICoffee produceCoffee(CoffeeType coffeeType) {
        ICoffee coffee;
        
        switch(coffeeType) {
            case Americano:
                coffee = new Americano();
                break;
            case Espresso:
                coffee = new Espresso();
                break;
            case Latte:
                coffee = new Latte();
                break;
            case Cappucino:
                coffee = new Cappucino();
                break;
            default:
                coffee = null;
        }
        
        return coffee;
    }
}
```



### 3.2 工厂模式（Factory）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。扩展性高，如果想增加一个产品，只要扩展一个工厂类即可。

> 题引：东方人喝不惯黑咖啡（Americano和Espresso）而喜欢喝加奶咖啡（Cappucino和Latte），所以需要根据地域需求来整改方案，通过黑咖啡工厂专门创建黑咖啡，当地黑咖啡需求低则降低产能，同理，当地加奶咖啡需求高则提高加奶工厂的产能；

{% asset_img designpattern2.png 设计模式 %}

```java
public class BlackCoffeeFactory {
    
    public ICoffee produceCoffee(CoffeeType coffeeType) {
        if (isNotBlackCoffee(CoffeeType coffeeType)) {
            throw new IllegalArguments("not black coffee");
        }
        return CoffeeStaticFactory.produceCoffee(coffeeType);
    }
    
    private boolean isNotBlackCoffee(CoffeeType coffeeType) {
        return coffeeType.equals(CoffeeType.Americano) || coffeeType.equals(CoffeeType.Espresso);
    }
}

public class MilkCoffeeFactory {
    
    public ICoffee produceCoffee(CoffeeType coffeeType) {
        if (isNotMilkCoffee(CoffeeType coffeeType)) {
            throw new IllegalArguments("not milk coffee");
        }
        return CoffeeStaticFactory.produceCoffee(coffeeType);
    }
    
    private boolean isNotMilkCoffee(CoffeeType coffeeType) {
        return coffeeType.equals(CoffeeType.Latte) || coffeeType.equals(CoffeeType.Cappucino);
    }
}
```



应用场景：在任何需要创建复杂对象的地方，都可以使用工厂方法模式。特别是对象有统一接口，或者创建的对象比较复杂，属于重对象比如线程池、数据连接池等。



### 3.3 抽象工厂模式（Abstract Factory）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂模式围绕超级工厂创建其他工厂，属于工厂类的抽象，或者说工厂的工厂。

> 题引：对于饮料类产品，中国人除了喝咖啡以为最爱喝的应该是茶了，所以需要一个创建茶的工厂来提供茶，同时咖啡工厂继续运营。

{% asset_img designpattern3.png 设计模式 %}

```java
public interface ITea{}
class GreenTea implements ITea{}
class RedTea implements ITea{}
class OolongTea implements ITea{}

enum TeaType {
    GreenTea, RedTea, OolongTea
}

public class TeaStaticFactory {
    
    public static ITea produceCoffee(TeaType teaType) {
        ITea tea;
        switch(teaType) {
            case GreenTea:
                tea = new GreenTea();
                break;
            case RedTea:
                tea = new RedTea();
                break;
            case OolongTea:
                tea = new OolongTea();
                break;
            default:
                tea = null;
        }
        return tea;
    }
}

// 抽象工厂
public abstract AbstractDrinkFactory {
    ICoffee produceCoffee(CoffeeType coffeeType);
    ITea produceTea(TeaType teaType);
}

public class TeaFactory extends AbstractDrinkFactory{
    @Override
    public ICoffee produceCoffee(CoffeeType coffeeType) {
		throw new IllegalArguments("not support produce coffee");
    }
    
    @Override
    public ITea produceTea(TeaType teaType) {
        return TeaStaticFactory.produceTea(teaType);
    }
}

public class BlackCoffeeFactory extends AbstractDrinkFactory {
    @Override
    public ITea produceTea(TeaType teaType) {
		throw new IllegalArguments("not support produce tea");
    }
    
    @Override
    public ICoffee produceCoffee(CoffeeType coffeeType) {
        if (!isBlackCoffee(CoffeeType coffeeType)) {
            throw IllegalArguments("not black coffee");
        }
        return CoffeeStaticFactory.produceCoffee(coffeeType);
    }
    
    private boolean isBlackCoffee(CoffeeType coffeeType) {
        return coffeeType.equals(CoffeeType.Americano) || coffeeType.equals(CoffeeType.Espresso);
    }
}

public class MilkCoffeeFactory extends AbstractDrinkFactory {
    @Override
    public ITea produceTea(TeaType teaType) {
		throw new IllegalArguments("not support produce tea");
    }
    
    @Override
    public ICoffee produceCoffee(CoffeeType coffeeType) {
        if (!isMilkCoffee(CoffeeType coffeeType)) {
            throw IllegalArguments("not milk coffee");
        }
        return CoffeeStaticFactory.produceCoffee(coffeeType);
    }
    
    private boolean isMilkCoffee(CoffeeType coffeeType) {
        return coffeeType.equals(CoffeeType.Latte) || coffeeType.equals(CoffeeType.Cappucino);
    }
}
```

### 3.4 原型模式（Prototype）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式是用于创建重复的对象，同时又能保证性能。说白了就是对象的克隆，创建一个与目标对象“一模一样“的另一个对象（哈希值不同）。

> 题引：通过原型模式创建不同咖啡的副本。

{% asset_img designpattern4.png 设计模式 %}

```java
public interface ICoffee {}
class Americano implements ICoffee, Clonable {
    private String coffeeBean; // 咖啡豆品种
    private String coffeeBakeDuration; // 咖啡豆烘焙时间
    private String extractTech; // 提取工艺
    
    public Americano(String coffeeBean, String coffeeBakeDuration, String extractTech) {
        this.coffeeBean = coffeeBean;
        this.coffeeBakeDuration = coffeeBakeDuration;
        this.extractTech = extractTech;
    }
    
    @Override
    public Object clone() {
        return super.clone();
    }
}
// 其他咖啡类型一致，省略

class CoffeePrototype {
    publc static generatePrototype(ICoffee coffee) {
        ICoffee prototype = null;
        try {
            prototype = (ICoffee) coffee.clone();
        } catch (CloneNotSupportedException e) {
            // 克隆异常处理
        }
        return prototype;
    }
}

// 伪代码调用
ICoffee coffee = new Americano("cuba coffee bean", "10 hours", "cold brew");
ICoffee coffeePrototype = CoffeePrototype.generatePrototype(coffee);
coffee == coffeePrototype; // false
```



在使用原型模式时，要注意**深浅克隆**，当对象成员变量使用基本数据类型时，可以直接使用clone方法，因为clone方法默认是浅克隆，如例子中的Americano；当成员变量含有非基本数据类型的对象，那么需要将对象进行深克隆，即对非基本数据类型的对象进一步递归clone实现。

> 深克隆举例，使用设计模式（一）中关联关系的例子

```java
class Customer implements Clonable {
    private int id;
    private List<Product> products;
    private Account account;
    // getter and setter
    
    // 成员变量非基本数据类型，需要采用深克隆
    @Override
    public Object clone() {
		Customer customer = (Customer) super.clone();
        Account account = this.account.clone();
        List<Product> products = new ArrayList<>();
        // 递归列表深克隆Producet对象
        for (Product p : this.products) {
            Product prototype = (Product) p.clone();
            products.add(prototype);
        }
        customer.setProducts(products);
        customer.setAccount(account);
        return customer;
    }
}

class Product implements Clonable {
    private int id;
    private int count;
    
    // 基本数据类型直接使用浅克隆
    @Override
    public Object clone() {
        return super.clone();
    }
}

class Account implements Clonable {
    private double balance;
    
    // 基本数据类型直接使用浅克隆
    @Override
    public Object clone() {
        return super.clone();
    }
}
```



### 3.5 建造者模式（Builder）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个复杂对象，特别是构造器入参多的大对象，可以采用构建着模式逐步录入参数从而构建出一个完整的对象。建造者模式一般分为经典的”原型创建“和”链式创建“。在《effective java》一书中，bloch推荐使用链式写法，更直观且更容易理解。

**原型创建**的原理是把一个复杂对象拆分成多个部分分别创建，最终组装成一个整体完整对象。一般原型创建分为四个步骤：

1. Product：最终被建造的对象。
2. Builder：被建造的对象需要遵从的统一标准接口。
3. Director：建造Product的统一对象。
4. BuilderImpl：具体的接口实现者。

> 题引：通过建造者模式创建具有不同性格、体型、样貌等特征的人

```java
class Human {
    private String feature; // 样貌
    private String size; // 体型
    private String sex; // 性别
    private String intelligence; // 智力
    // getter and setter
}

// 造人的标准规范
public interface IHumanBuilder {
    void buildFeature();
    void buildSize();
    void buildSex();
    void buildIntelligence();
    Human buildHuman();
}

// 创建一个身材矮小但聪明的男人
class HumanOneBuilderImpl implements IHumanBuilder {
    private Human human;
    public HumanOneBuilderImpl(Human human) {
        this.human = human;
    }
    
    void buildFeature() {
        human.setFeature("random");
    }
    
    void buildSize() {
        human.setSize("small");
    }
    
    void buildSex() {
        human.setSex("male");
    }
    
    void buildIntelligence() {
        human.setIntelligence("smart");
    }
    
    Human buildHuman() {
        return human;
    }
}

// 创建一个体型高硕，美丽的女人
class HumanTwoBuilderImpl implements IHumanBuilder {
    private Human human;
    public HumanOneBuilderImpl(Human human) {
        this.human = human;
    }
    
    void buildFeature() {
        human.setFeature("beauty");
    }
    
    void buildSize() {
        human.setSize("tall");
    }
    
    void buildSex() {
        human.setSex("female");
    }
    
    void buildIntelligence() {
        human.setIntelligence("random");
    }
    
    Human buildHuman() {
        return human;
    }
}

// 对象的组装过程是有先后顺序的，该类就是统一的按照一定顺序规则构建对象的指挥者
class Director {
    public Human createHuman(IHumanBuilder builder) {
        builder.buildFeature();
        builder.buildSize();
        builder.buildSex();
        builder.buildIntelligence();
        return builder.buildHuman();
    }
}

// 测试调用，伪代码
Director director = new Director();
HumanOneBuilderImpl humanBuilder1 = HumanOneBuilderImpl(new Human());
HumanTwoBuilderImpl humanBuilder2 = HumanTwoBuilderImpl(new Human());
Human human1 = director.createHuman(humanBuilder1);
Human human2 = director.createHuman(humanBuilder2);
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经典的建造者模式是程式化的，在理解和使用上并不直观，如果对象足够复杂，每个Builder接口的实现类也会复杂。所以就引申出了”链式建造者模式“。



**链式建造者模式**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链式建造者模式通常在复杂对象内部创建一个专属的Builder内部类，对于共性特征可以不必从客户端输入，而只关注可变的参数。我个人觉得，最最最大的优点在于，目前IT行业公司都有各自的 ”编码规范“，基本上规范内容都会要求方法参数个数应该低于N个（我司编码规范要求方法入参必须保证不大于5个），所以在创建对象时如果不是使用不优雅的setter方法而是采用构造器创建，那入参问题必然会打破编码要求。**所以，链式建造者可以满足，不违反编码规范的前提下创建复杂对象 [doge]**

> 题引，通过链式建造者模式，创建具有不同特征的人。

```java
// 对上一例子中的Human进行改造
public class Human {
    private String feature; // 样貌
    private String size; // 体型
    private String sex; // 性别
    private String intelligence; // 智力
    private String color; // 肤色
    private String nation; // 国籍
    private String language; // 语言
    private Date birthDate; // 出生日期

    // 私有化构造器，只能通过构造器创建对象
    private Human(Builder builder) {
        feature = builder.feature;
        size = builder.size;
        sex = builder.sex;
        intelligence = builder.intelligence;
        color = builder.color;
        nation = builder.nation;
        language = builder.language;
        birthDate = builder.birthDate;
    }

    // getter and setter

    // 内部构造器对象
    public static class Builder {
        private String feature;
        private String size;
        private String sex;
        private String intelligence;
        private String color;
        private String nation;
        private String language;
        private Date birthDate;

        public Builder feature(String feature) {
            this.feature = feature;
            return this;
        }

        public Builder size(String size) {
            this.size = size;
            return this;
        }

        public Builder sex(String sex) {
            this.sex = sex;
            return this;
        }

        public Builder intelligence(String intelligence) {
            this.intelligence = intelligence;
            return this;
        }

        public Builder color(String color) {
            this.color = color;
            return this;
        }

        public Builder nation(String nation) {
            this.nation = nation;
            return this;
        }

        public Builder language(String language) {
            this.language = language;
            return this;
        }

        public Builder birthDate(Date birthDate) {
            this.birthDate = birthDate;
            return this;
        }

        // 最终构建完整对象
        public Human build() {
            return new Human(this);
        }
    }
}

// 使用，伪代码
Human.Builder builder = new Human.Builder();
Human human = builder.feature("beauty").size("average").sex("female").intelligence("genius")
    				 .color("yellow").nation("China").language("Chinese").birthDate(new Date())
    				 .build();
```



```java
// 假如我们要创建中国人，其实color、nation和language已经确定，并且Date与创建时间有关，所以这些参数可以被Builder内部创建好。
// 创建中国人，Builder修改如下， 伪代码
public class Human {
    // 各种参数和构造器实现，省略...
    public static class Builder {
        private String feature;
        private String size;
        private String sex;
        private String intelligence;
        private String color = "yellow";
        private String nation = "China";
        private String language = "Chinese";
        private Date birthDate = new Date();

        public Builder feature(String feature) {
            this.feature = feature;
            return this;
        }

        public Builder size(String size) {
            this.size = size;
            return this;
        }

        public Builder sex(String sex) {
            this.sex = sex;
            return this;
        }

        public Builder intelligence(String intelligence) {
            this.intelligence = intelligence;
            return this;
        }

        // 最终构建完整对象
        public Human build() {
            return new Human(this);
        }
    }
}
// 使用
Human.Builder builder = new Human.Builder();
Human chinese = builder.feature("beauty").size("average").sex("female").intelligence("genius").build();
```



### 3.6 单例模式（Singleton）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式是为了保证在对象任何被调用的时刻，对象状态永远不变，即不会在内存中存在两个相同的对象。单例模式分为多种，以下将从最简单的单例模式入手不逐步找出问题和解决问题，最终推出 “完美单例模式”。

**饿汉式单例**

```java
public class Singleton {
    private static final INSTANCE = new Singleton();
    
    private Singleton(){}
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}

```

饿汉式单例模式总结如下：

1. 利用常量特性，在类加载结束后就会创建INSTANCE对象，并通过常量方法返回该对象。
2. 类加载后创建，所以**不支持懒加载**。
3. 类加载后创建，所以**线程安全**。



**懒汉式单例**

> 专门吐槽一下，也不知道最早是谁翻译的“懒汉”、“饿汉”，真的是醉了，懒汉式应该是**Lazy**的翻译，或许叫延时加载更合适。“饿汉式”还真没找到出处，或许是 “Hungry" 或者 ”Starve“ 吧？

```java
public class Singleton {
    private static instance = null;
    
    private Singleton(){}
    
    public static Singleton getInstance() {
        if (Objects.isNull(instance)) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

懒汉式总结：

1. 初始null，在被调用时创建，所以**支持懒加载**；
2. 使用全局变量instance，所以在getInstance方法时容易产生线程安全问题，所以**非线程安全**；
3. **反射不安全**、**反序列化不安全**。



**懒汉式单例改进——双检锁+防反射攻击+防反序列化攻击**

```java
public class Singleton {
    private static instance = null;
    
    private Singleton(){
        // 防止反射攻击
        if (!Objects.isNull(instance)) {
            throw new IllegalStatException("不支持反射创建对象");
        }
    }
    
    // 双检锁
    public static Singleton getInstance() {
        synchronized(Singleton.class) { // 非空判断前加锁
            if (Objects.isNull(instance)) {
                 synchronized(Singleton.class) { // 对象创建前加锁
                	instance = new Singleton();
                 }
        	}
        }
        return instance;
    }
    
    // 保证反序列化对象为当前实例对象
    private Object readResolve() {
        return instance;
    }
}
```

总结：

1. **序列化安全、反射安全、延迟加载**；
2. 在**《多线程》系列**中介绍了双检锁的线程安全问题，这里简单提一下，虽然对创建instance的动作采取双检锁加锁，但是`instance = new Singleton()`动作并不具有原子性，可能存在以下情况：假设A线程和B线程同时访问`getInstance()`方法，A线程检测到当前`instance = null`所以同步开始创建第一个实例，当动作执行到`instance = new Singleton()`时，因为不具有原子性，可能出现这样情况：JVM在内存中创建了Singleton的内存空间，所以instance不为空，但是对象创建过程中需要经过"**加载 -> 链接 -> 初始化**"，在**链接过程中会对instance分配内存空间但是对象本身不存在**，此时线程B检测到instance不为null，直接获得没有完全初始化的Singleton实例，导致出现线程安全问题。



**完美单例1——懒汉式静态类单例**

```java
public class Singleton {
    
    private Singleton(){
        // 防止反射攻击
        if (!Objects.isNull(instance)) {
            throw new IllegalStatException("不支持反射创建对象");
        }
    }
    
    public static Singleton getInstance() {
        return InstanceHolder.INSTANCE;
    }
    
    // 保证反序列化对象为当前实例对象
    private Object readResolve() {
        return instance;
    }
    
    private static final class InstanceHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
}
```

总结：

1. 利用静态内部类特性，当首次调用静态内部类常量时才进行创建，所以**支持懒加载**；
2. 利用常量特点，JVM加载类加载器\<clinit>时，可以保证线程阻塞单线程执行，所以**线程安全**；
3. **反射安全、反序列化安全**。



**完美单例2——枚举单例**

```java
public enum Singleton {
    INSTANCE
}

// 伪代码调用
Singleton instance = Singleton.INSTANCE;
```

总结：枚举单例是最简单的方式，也是《effective java》推荐使用的单例模式，原因在于JVM天然的保证枚举类型的单一性：

- 枚举对象与静态内部类一样，在首次访问时才会初始化对象，所以**支持懒加载**;
- 枚举对象属于常量，所以可以保证**线程安全**；
- 枚举类内部重写readObject()方法，所以**反序列化安全**。

```java
public abstract class Enum<E extends Enum<E>>
        implements Comparable<E>, Serializable {
	/**
     * Sole constructor.  Programmers cannot invoke this constructor.
     * It is for use by code emitted by the compiler in response to
     * enum type declarations.
     */
    protected Enum(String name, int ordinal) {
        this.name = name;
        this.ordinal = ordinal;
    }
    
    /**
     * prevent default deserialization
     */
    private void readObject(ObjectInputStream in) throws IOException,
        ClassNotFoundException {
        throw new InvalidObjectException("can't deserialize enum");
    }
}
```

- 反射包内的构造器对象`Constructor`对通过构造器创建对象实例特别约束了枚举类型，如果创建实例是枚举类型将抛出 IllegalArgumentException 异常，所以**反射安全**。

```java
public T newInstance(Object ... initargs)
        throws InstantiationException, IllegalAccessException,
               IllegalArgumentException, InvocationTargetException
    {
        if (!override) {
            Class<?> caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, clazz, modifiers);
        }
        // 如果创建实例是枚举类型将抛出 IllegalArgumentException 异常
        if ((clazz.getModifiers() & Modifier.ENUM) != 0)
            throw new IllegalArgumentException("Cannot reflectively create enum objects");
        ConstructorAccessor ca = constructorAccessor;   // read volatile
        if (ca == null) {
            ca = acquireConstructorAccessor();
        }
        @SuppressWarnings("unchecked")
        T inst = (T) ca.newInstance(initargs);
        return inst;
    }
```

