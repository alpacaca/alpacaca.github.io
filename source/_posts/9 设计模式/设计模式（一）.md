---
title: 设计模式（一）
date: 2020-6-5
tags: [设计模式]
---
{% asset_img image1.jpg 设计模式 %}

# 设计模式（一）
<!--more-->

## 1 设计模式概述和设计原则



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式最早由建筑行业提出，随着从业经验的不断累积和迭代，如何按照既定的原则和目标建造出安全、稳定、美观的大楼，这就是设计模式。一砖一瓦一楼阁，平地间筑起高楼。软件工程同样有自身的一套前人总结的设计经验，代表了最佳的实践，是软件开发过程中面临的一般问题的解决方案。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GoF(Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides) 四人合著了一本经典书籍——《Design Pattern》，该书大获成功，书中介绍了23种设计模式，实际软件工程演变到现金已经远远超过23种，但这23种设计模式仍然可以普遍应用于实际开发过程中，也是设计模式学习的基础。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式按照使用场景可以划分为：**创建型设计模式、结构型设计模式和行为型设计模式**：

- 创建型设计模式：（5种）
  - 工厂模式、抽象工厂模式、单例模式、原型模式、建造者模式

- 结构型设计模式：（7种）
  - 适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、亨元模式
- 行为型设计模式：（11种）
  - 策略模式、模版模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式是解决问题的手段，而指导设计模式的思想称为设计原则：**单一职责原则、接口隔离原则、依赖倒置原则、里氏替换原则、迪米特法则、开闭原则、组织/聚合原则**，共7种（组合/聚合是比较新的设计原则）

- **单一职责原则**：作为高级面向对象语言，Java的单一职责性原则很重要，作为类，一个类只负责完成一个功能领域中的职责；作为方法，一个方法只实现单一功能。单一职责原则是高内聚、低耦合的核心思想。



- **接口隔离原则**：作为抽象层级的顶级设计，接口必须具备隔离原则，即尽可能的创建功能单一的接口，而不创建”大而全“的总接口，这样可以保证实现类只重写相关的方法，而不用重写不相关的方法。

{% asset_img designpatter1.png 设计模式 %}

> 在该设计中Bird接口可以满足Parrot和Eagle，可是Ostrich鸵鸟也属于鸟类，但是鸵鸟并不会飞 (fly()方法)，但是鸵鸟不得不重写 fly 方法，所以需要对Bird接口重新设计。



- **依赖倒置原则**：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。在对象关联关系中尽量引用层次高的抽象层类而不要用具体类

```java
interface Shape{}
class Circle implements Shape{}
class Rectangle implements Shape{}
class Triangle implements Shape{}

// 引用类型使用Shape而非具体实例类型
Shape shape1 = new Circle();
Shape shape2 = new Rectangle();
Shape shape3 = new Triangle();

```



- **里氏替换原则**：所有引用基类（父类）的地方必须能透明地使用其子类的对象，换而言之基类调用的地方换成子类也应该可以正常调用，所以可以认为里氏替换原则是规定**子类尽量避免重写父类方法**，如果不得不重写父类方法可以采用关联关系，而非继承关系。



- **迪米特法则：**也称为”最少知道原则“或”最少知识原则“，设计开发时应当尽可能少地与其他实体发生相互作用，换而言之，一个类A与另一个类B存在关联关系，A调用B的方法，B应该只提供简单的对外接口而屏蔽内部实现的复杂性。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。



- **开闭原则**：程序应当对扩展开放，对修改关闭。即应尽量在不修改原有代码的情况下进行扩展。抽象化设计是开闭原则的关键。



- **组合/聚合原则**：如果直接继承基类，因为继承将基类的实现细节暴露给子类从而破环基类的封装性；如果基类的实现发生改变，则子类的实现也不得不发生改变。所以程序的设计应当避免使用继承关系而使用组合/聚合的方式替换，也因此可以避免里氏替换原则的问题。



## 2 关联关系及其UML表示

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前文提到的组合/聚合就是对象之间关联关系的其中之二，在面向对象中，关联关系是表示对象与对象之间的关系，它包括：泛化（继承）、实现、关联、依赖、组合、聚合六种。

**泛化（继承）和实现**： 在UML中继承关系通常称为泛化关系，表示父类与子类之间的继承关系；实现，顾名思义就是类与接口之间的关系。

{% asset_img designpatter2.png 设计模式 %}

```java
public class Rectangle extends Shape{} // 继承关系

public class Human implements Mammal{} // 实现关系
```



**关联和依赖**：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**关联**：可以表示为单项关联和双向关联，对于类A和B，B作为A的成员变量使用，那么A和B属于单项关联关系；对于类A和B，B作为A的成员变量，A作为B的成员变量，那么A和B属于双向关联关系。

{% asset_img designpatter3.png 设计模式 %}

```java
class Customer {
    private List<Product> products;
    private Account account;
}

class Product {
    private int id;
    private int count;
}

class Account {
    private Customer customer;
    private double balance;
}
```



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**依赖**：对于类A和B，B的对象作为A的方法入参或局部变量使用，那么A和B属于依赖关系。

{% asset_img designpatter4.png 设计模式 %}

```java
class Coffee {}

class CoffeeFactory {
    
    public void produceCoffee(Coffee coffee) {}
    //或者
    public void produceCoffee() {
        Coffee coffee = new Coffee();
    }
}
```



**组合和聚合**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**组合**：对于类A和B，B作为A的成员变量使用，并且自身对象内部创建B对象实例使用，也就是说A对象负责B对象的生命周期。

{% asset_img designpatter5.png 设计模式 %}

> 车辆是最终需要的对象，而车辆对象离不开轮胎对象、发动机对象、变速箱对象和方向盘对象。所以它们是组合关系。

```java
class Tyre {}
class Engine {}
class Steering {}
class GearBox {}

class Automobile {
    private Tyre tyre = new Tyre();
    private Engine engine = new Engine();
    private Steering steering = new Steering();
    private GearBox gearBox = new GearBox();
    
    // 或者采用其他方法创建
    
    private Tyre tyre;
    private Engine engine;
    private Steering steering;
    private GearBox gearBox;
    
    public Automobile() {
        init();
    }
    
    private void init() {
        tyre = new Tyre();
        engine = new Engine();
        steering = new Steering();
        gearBox = new GearBox();
    }
}

```



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**聚合**：在表现形式上聚合和关联关系一致，对于类A和B，B作为A的成员变量使用，并且通过set等方法或构造器赋值，通过外部传入供A使用。

{% asset_img designpatter5.png 设计模式 %}

```java
class Screen{}
class Keyboard{}
class Mouse{}

class Computer {
    private Screen screen;
    private Keyboard keyboard;
    private Mouse mouse;
    
    // 构造器传入
    public Computer(Screen screen, Keyboard keyboard, Mouse mouse) {
        this.screen = screen;
        this.keyboard = keyboard;
        this.mouse = mouse;
    }
    
    // 或者set方法传入
    public void setScreen(Screen screen){
        this.screen = screen;
    }
    
    public void setKeyboard(Keyboard keyboard) {
        this.keyboard = keyboard;
    }
    
    public void setMouse(Mouse mouse) {
        this.mouse = mouse;
    }
}
```



> 组合和聚合除了外部对象创建方式不同之外，还体现在对象主体与组成对象的强依赖关系：对于汽车对象必须要有轮胎、发动机等对象来构成一台完整的车；对于电脑来说，键盘、显示器和鼠标并不是必须的，缺少其中之一并不影响电脑的构成，打个比方，如果将图示内容的聚合对象改为CPU、内存、硬盘等，那么就构成了组成关系。
>
> 总的来说，组合的耦合性高于聚合。