---
title: 多线程基础（一）
date: 2020-5-27
tags: [多线程]
---
{% asset_img image1.jpg 多线程 %}

# 多线程基础（一）
<!--more-->

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前的计算机硬件已经突破了**摩尔定律**，CPU的算力可以达到每秒百亿次甚至更高，个人PC可运行的软件包括操作系统在内，进程数可以是几十个，线程数甚至更多，为了更大程度的发挥计算机自身算力，提高系统效率，更多会采用多线程并发编程的方式实现。



## 1 进程、线程、并行、并发和同步

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为计算机理论的基础知识，**进程，是资源分配的最小单位；线程，是CPU调度的最小单位；线程依赖进程而执行；进程资源相互之间是独立的，线程共享同一个进程内的资源**。一个程序在计算机上启动并运行，它就需要获得资源，就是一个进程；这个程序在计算上如何被CPU调度运行，就是一个或多个线程。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPU执行程序实际调用的是指令集，现代计算机基本都是多核CPU，这就允许创建更多的进程，而**多个进程同时运行，称作并行；在一个进程内，多个线程同时运行，称作并发；多个线程由于共享进程资源，在并发执行时会竞争资源，需要采取策略避免因为资源竞争而产生脏数据等线程安全问题，这种策略就称为同步。** 在线程同步执行过程中，可以对单个线程处理的资源独占加锁，其他线程需要等待独占锁被释放才能继续执行，这个等待的过程称为**阻塞**。

> 引用知乎一句话:(https://zhuanlan.zhihu.com/p/54297968)
>
> 有人的地方就有江湖，
>
> 有并发的地方就有资源竞争，
>
> 有竞争的地方就有线程安全，
>
> 有线程安全的地方就有同步，
>
> 有同步的地方就有锁。



## 2 多线程的状态和使用

{% asset_img threadstate.png 多线程状态 %}

1. 创建状态，Java中创建线程的方式有三种：继承Thread类、实现Runnable接口、实现Callable接口。其中Callable接口属于具有回调结果并可以抛出异常的接口，其实现方法是call；而普通创建线程推荐使用Runnable接口，对外暴露接口少，实现方法是run()，其内部异常只能通过主线程调用setDefaultUncaughtExceptionHandler()来捕获。
2. 就绪状态，执行start之后线程并不会立即执行，而是进入就绪状态等待CPU分配执行时间片。线程是“一次性消费”，并不能被多次执行start方法。
3. 运行状态，线程执行run方法，但执行过程中会被各种原因打断进入阻塞状态。
4. 阻塞状态，线程阻塞是多方面援引，包含**主动阻塞，即调用sleep、yield、join等；等待阻塞，调用了wait需要通过notify唤醒；同步阻塞，当前线程执行的资源被其他线程独占。**
5. 结束状态，执行结束或异常退出，当前线程被释放或回归线程池。



**使用Thread和Runnable创建线程**

```java
// 使用Thread执行
public class RunTask extends Thread {

    @Override
    public void run() {
        System.out.printf("当前线程： %s 执行", Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        RunTask runTask = new RunTask();
        runTask.setName("runTask1");
        runTask.start();
    }
}

// 使用Runnable执行
public class RunTask implements Runnable {

    @Override
    public void run() {
        System.out.printf("当前线程： %s 执行", Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        RunTask runTask = new RunTask();
        Thread thread = new Thread(runTask);
        thread.setName("taskRun2");
        thread.start();
    }
}

// 使用lambda执行Runnable
public class RunTask {

    public static void main(String[] args) {
        new Thread(() -> {
            System.out.printf("当前线程 %s 执行", Thread.currentThread().getName());
        }, "runTask3").start();
    }
}
```



**使用Callable执行线程**

```java
public class RunTask implements Callable<String> {

    @Override
    public String call() {
        System.out.printf("当前线程： %s 执行 \n", Thread.currentThread().getName());
        return "runTask4 over";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        RunTask runTask = new RunTask();
        FutureTask<String> futureTask = new FutureTask<>(runTask);
        new Thread(futureTask, "runTask4").start();
        System.out.println(futureTask.get());
    }
}
// output: 
// 当前线程： runTask4 执行 
// runTask4 over
```

当然，在Java世界中多线程执行使用最广泛的还是线程池套件，稍后介绍。



## 3 线程安全机制

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多线程并发下的线程安全是决定系统性能的重要因素，其核心理念是**“要么只读，只要加锁”**。在早期的Java版本中，经常需要手写线程池或线程安全代码，往往会造成严重的性能问题，随着Java引入**java.util.concurrent**包使得并发编程难度降低，且具有更优秀的性能。线程安全问题可以按照以下的顺序思考：

1. 资源向线程内移动，全局的共享资源是产生线程安全的根本援引，并且每个线程在JVM中独立拥有栈帧，如果允许的话可以将资源设置为局部变量，从而屏蔽线程安全问题，这也是ThreadLocal的核心理念。
2. 不可变对象设计，不可变对象因为外部无法修改，它永远只是只读的，所以它总是安全的，例如String类型和Number类型等。
3. 使用线程安全的对象，java原生提供了很多线程安全的类，比如：集合领域使用concurrent下的集合ConcurrentXXX对象或者CopyOnWriteXXX对象等，或者Collections提供的对非线程安全集合创建互斥锁转变为线程安全；StringBuffer等等。
4. 同步机制和锁，涉及并发修改需要考虑实现同步机制，比如synchronized或者锁Lock（ReetrantLock）等。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回过头来，对线程安全下一个定义，这个定义没有官方的或者权威的定论，个人认为适时且恰当的定义来自《Java并发编程》中的描述：“当多个线程同时访问一个对象时，①如果不考虑这些线程在运行时环境下的调度和交替执行，②也不需要进行额外的同步，③或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。”



## 4 多线程特性

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**原子性**是多线程的重要特点之一，所谓原子性是指在JVM字节码中的一个执行指令，JVM可以保证一个指令的执行是原子的，但不保证多个原子的指令执行是安全的。与事务中的原子性概念类似，原子指令执行过程中要么全部成功，如果失败则全部退出。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例说明，赋值语句`int i = 1;`是典型的原子指令，而自增`++i`在字节码中需要分别执行"对i赋值给临时变量"、"数值加1"、”返回结果保存“，对应的指令是”ILOAD、IINC、ISTORE“，虽然每一步都是原子的，但是组合在一起失去了原子性，是非线程安全的。在java.util.concurrent.atom包下，定义了一批原子性的对象，如AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference等等，其内部api涉及诸如自增之类的方法，通过CAS（稍后介绍）实现原子性。

再比如，long类型是8字节64位，在32位操作系统中，对long类型进行赋值就不具有原子性。

```java
// AtomicInteger的自增方法
public final int getAndIncrement() {
    for(;;) {
        int current = get(); // 预期值
        int next = current + 1; // 新值
        if (compareAndSet(current, next)) { // 自旋
            return current;
        }
    }
}

// unsafe来自native方法，支持直接调用硬件的原子性能力。
public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**可见性**，多线程在JVM内存中是基于内存共享的，因为不同的线程独占工作栈，当对共享对象进行修改需要重新刷新到主内存中，以便其他线程也可以基于最新的对象进行操作，当多个线程对同一个共享对象进行操作，容易造成内存同步不及时导致的线程安全问题。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**有序性**，通常认为程序的运行是按照字节码顺序执行的，但实际上CPU会对信息进行**指令优化**，分析哪些动作可以合并进行，从而导致看上去后面的代码先执行了。但是可以保证整体顺序是不变的，不会造成由于优化引起的乱序现象。



## 5 内存模型和Volatile

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个线程都有独占的内存空间（操作栈、本地变量表等等）称为**工作内存**，同时还存在对所有线程开放的共享区域，称为**主内存**。线程在本地内存对共享对象修改后，会将结果同步到主内存中，既然有同步操作就会存在时间差，而再次期间的操作对于其他线程来说却是不可见的。

{% asset_img JMM.png JMM %}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**Java内存模型（Java Memory Model，JMM）主要目的是定义程序中各种变量的访问规则**，变量范围包括实例属性、方法属性等这些可以被共享的变量，而局部变量和方法参数等属于线程本地内存所有，是线程独占的。JMM同时规定：**所有的变量保存在主内存中，工作内存保存线程使用的主内存中变量的副本，每个线程对变量的操作都必须在工作内存中完成，而不能直接读写主内存中的数据**。

> “不能直接读写主内存中的数据”
>
> 这一描述对volatile也不例外，虽然看上去volatile描述的对象修改就是在主内存中完成，但事实上，volatile是通过特殊的操作顺序来完成这一点（确保在读操作之前先执行写入操作），实际依然有工作内存的拷贝。

> JMM 和 JVM内存区域如堆、栈、方法区等概念属于不同维度对内存的描述，实际上JMM主要是针对JVM在硬件访问层面的描述。



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更好的提供多线程可见性的特性，JMM专门为volatile定制了特殊的访问规则：

1. 保证volatile描述的变量对所有线程的可见性，即保证一致性。
2. 禁止指令重新排序优化。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对所有线程的可见性容易理解，它可以保证不同的线程修改共享变量后能够及时的刷新回内存中而对其他线程可见，从而保证了数据的一致性，但是，并不是volatile描述的变量就是线程安全的，这依赖于变量自身的原子性。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前文已经提到过，字节码指令在计算机中被CPU调用时并不是严格按照顺序进行，而是会被重新排序进行合并优化，即只要保证结果正确性而不考虑执行顺序的乱序。禁止指令重排序其实是指在关键的动作之前，其依赖的动作已经完成，反应到volatile上就是共享变量在被线程B读取之前已经从线程A修改后的变量写入主内存中。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里提一下有名的单例模式创建机制——双检锁（Double Check Lock, DCL）,它是指在创建单例对象时，在加锁前后都判断对象是否为空，但DCL并不一定是线程安全的。

```java
// 双检锁机制的单例模式
public class DCLSingleton {

    private volatile static DCLSingleton instance;
    private Object o = new Object();
    
    private DCLSingleton() {}
    
    public static DCLSingleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (DCLSingleton.class) {
                if (instance == null) { // 第二次检查
                    instance = new DCLSingleton();
                }
            }
        }
    }
}
```

理论上，双检锁已经把单例创建发挥到极致，但为什么它还可能是线程不安全的？主要问题在于`instance = new DCLSingleton();`，这句话在字节码层面并不具有原子性，假如线程A创建单例时执行到`new DCLSingleton();`，此时对象已经在内存中分配了空间但并没有完全完成初始化（还没有创建Object对象），经过volatile修饰此时被刷新回了主内存，而线程B调用了`getInstance`方法返回的对象也是没有完全初始化的对象，从而引起线程安全问题。



## 6 Happern-Before原则

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Happen-Before原则又称为先行发生原则，它是JMM中关于两个操作之间的顺序关系的保证！比如A happen before B，就是说在B进行操作前，A的操作造成的影响可以被B观察到。用函数关于可以表示成 F(x,y) 其中 x 先行发生于 y 。如果有三个线程A、B、C，它们之间的函数关系是 F(A,B) 和 F(B,C)，那么可以推导出 F(A,C)是成立的。尽管会进行指令的重排序，到只要保证最终的happen-before规则，其中的重排序是可以被允许的。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“时间上的先发生”并不代表先行发生。

```java
private int value;

public int getValue() { return value;}

public void setValue(int value) {this.value = value;}
```

假如线程A先执行setValue，线程B后执行getValue，虽然在时间上“A先于B执行”，但并不满足happen-before原则，所以它还是线程不安全的。然而，先行发生也不意味着就会是“时间上的先发生”，有以上描述可以得知，还有可能存在指令重排序。



## 7 ThreadLocal和引用类型

**引用类型**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中存在四种引用类型，主要适用于在GC机制不同阶段下的引用对象定义：

> 这里所说的GC机制基于HotSpot VM。

```java
// 强引用类型
Object object = new Object();
```

1. 强引用类型，也就是最普通的引用类型，在从GC ROOTS开始对象可达性分析时，如果不在引用链上就会被GC当作垃圾对象回收。一般发生在 Minor GC 和 Major GC阶段。

```java
// 软引用类型
SoftReference<Object> softObject = new SoftReference<>(new Object());
```

2. 软引用类型，是比强引用效果弱一些的引用类型，在JVM内存体积膨胀到即将OOM前，GC会统一清理软饮用类型对象，以获得更多的空间避免发生OOM。通常用于缓存中间数据，当OOM前清理了缓存会在后续重新建立，延长了系统运行时间。

```java
// 弱引用类型
WeakReference<Object> weakObject = new WeakReference<>(new Object());
```

3. 弱引用类型，是比软引用效果更弱的引用类型，在GC执行Minor GC时就会清理的类型，由于Minor GC发生的频率大于Major GC且发生时间不定，所以被回收的时间也无法确定。通常用于保存容易在内存中消失的对象。

```java
// 引用队列
ReferenceQueue<Object> phantomQueue = new ReferenceQueue<>();
// 虚幻引用类型
PhantomReference<Object> phantomObject = new PhantomReference<>(new Object(), phantomQueue);
```

4. 虚幻引用类型，是效果最弱的引用类型，在创建之后就无法获得引用对象，创建时还需要赋值引用队列`ReferenceQueue`，当GC回收虚幻引用时，会将该对象加入队列中再回收。它唯一应用的场景就是对象被回收时，通过引用队列被外界知道。

   

**ThreadLocal**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal是一种新的多线程并发安全设计思想的实现，全局变量并发操作总是充满不安全性，那么如果将全局变量设计为线程私有副本呢？ThreadLocal内部通过ThreadLocalMap的哈希表结构来保存变量的副本，哈希表的key就是当前ThreadLocal对象，value是持有的变量副本，而每个ThreadLocalMap对象都是Thread对象私有的。

```java
// 源码
public class Thread implements Runnable {
    ...
	ThreadLocalMap threadLocals;
    ...
}

public class ThreadLocal<T> {
    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocal.ThreadLocalMap map = this.getMap(t); // 从当前线程获得ThreadLocalMap
        if (map != null) {
            map.set(this, value); // key为当前ThreadLocal对象，value是目标值
        } else {
            this.createMap(t, value);
        }
    }
    
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocal.ThreadLocalMap map = this.getMap(t);// 从当前线程获得ThreadLocalMap
        if (map != null) {
            // 获得当前对象的键值对，key为当前ThreadLocal对象,value是变量副本
            ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                T result = e.value; 
                return result;
            }
        }

        return this.setInitialValue();
    }
}


```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当某个频繁操作需要一个临时对象，同时希望避免每次重新分配对象就可以采用这种方式，比如在开发数据库连接时，JDBC连接是容易产生并发问题的，可以将每个连接私有到当前处理的线程中，在通过ThreadLocal调用各自的连接获得不受干扰的执行结果并返回。当线程终止，这些值会被GC回收。

```java
// 伪代码
private static final String JDBC_URL = "jdbc:///mysql"

private static ThreadLocal<JDBCConnection> connectionHolder = 
    new ThreadLocal<JDBCConnection>(){
    @Override
    public JDBCConnection initialValue() {
        return DriverManager.getConnection(JDBC_URL);
    }
}
```

在多线程场景下，同一线程内的跨方法数据传递就需要使用ThreadLocal，如果没有使用它就必须通过返回值和参数形式，增加了相互间耦合度。

 

**ThreadLocal弊端**

1. 内存泄漏，在ThreadLocal文档中要求一般声明ThreadLocal<>对象是private static的，通过GC可达性分析算法来看，静态变量会被选定为GC ROOT从而一直存在于内存当中，并不会随着线程结束而释放，所以在线程中**使用完ThreadLocal之后必须调用remove()方法进行释放**，否则就会在内存中堆积产生内存泄漏问题。

{% asset_img weakreference.png weakreference %}

> ThreadLocal产生内存泄漏的原因与Entry对象保存的key是否是弱引用WeakReference无关，因为如果key是强引用，当线程执行结束之后，虽然key在Minor GC之后会被回收，但Entry对象还存在于内存中。

2. 脏数据，脏数据之所以会发生，可想而知，其根本原因在于绑定的线程Thread在执行一次之后并没有被销毁，而用于其他线程使用，此场景就是线程池的线程复用情况，假如之后线程不适用set()方法设置值，直接调用get()，那么就会得到之前线程执行后的值，造成脏数据。**要解决脏数据问题，还是必须在使用完毕后调用remove()方法释放**。



**ThreadLocal和Synchronized区别**

|          | synchronized                                                 | ThreadLocal                                                  |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 思路     | 采用对变量加锁的方式解决兵法问题，<br />是一种“时间换空间”方式。 | 采用为每个线程提供一个变量的私有副本，<br />来隔离不同线程间的影响，是一种“空间换时间”的方式。 |
| 处理方式 | 加锁解决同步问题。                                           | 1.共享数据隔离。<br />2.同一线程内跨组件值传递。             |



## 8 Synchronized 和 锁

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文中谈到了线程安全，那么实际操作中保证线程安全最常用的方式之一就是采用**“互斥同步（Mutual & Synchronized）”**方式。



### 8.1 Synchronized

#### 8.1.1 synchronized的使用

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized关键字是最基础也是最常用的同步手段， 通过对一个实例对象或者类对象加锁以达到线程对方法的独占使用，对其他线程阻塞，直到持有锁的线程释放锁，阻塞队列里的线程才能再次竞争锁，即竞争同步方法的使用权。我们知道，synchronized不仅可以显式的指定加锁对象，也可以隐式的直接使用，如果不明确指定加锁对象，那么JVM会通过该方法判断（实例方法 or 类方法）使用当前对象的实例对象或者类对象。

```java
	class SynchronizedDemo {
        private Object param; // 全局对象变量

        private static int status = 0; // 全局类变量

        public synchronized Object getParam() { // 锁定实例对象
            return param;
        }

        public synchronized void setParam(Object param) { // 锁定实例对象
            this.param = param;
        }

        public void handleParam() {
            synchronized (this) { // 锁定实例对象
                param = new Object();
            }
        }

        public static void statusAccumulate() {
            synchronized (SynchronizedDemo.class) { // 锁定类对象
                status += 1;
            }
        }

        public static synchronized int getStatus() { // 锁定类对象
            return status;
        }
    }
```



#### 8.1.2 synchronized的字节码层实现原理

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，让我们从JVM底层字节码来分析synchronized的原理。当源码中使用synchronized锁定一段代码块时，字节码中表现为在该代码块前后添加monitorenter和monitorexit两个指令，这两个指令都依赖于一个明确指向的对象，即持有锁的对象（实例对象或者类对象）。**当 JVM 执行monitorenter时，会先判断持有的锁对象是否存在，如果对像不存在则当前线程进入阻塞队列，等待锁被释放与其他阻塞线程竞争锁；如果对象存在，那么就会将锁的计数器递增1，执行monitorexit会将锁计数器递减1，直到锁计数器为0时，当前线程释放锁。**也就是说synchronized是可重入的，也就存在线程自身的死锁情况发生。



#### 8.1.3 synchronized的优化和原理

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在历史上JDK5及以前版本中，synchronized都是通过调用硬件层的完全互斥方式解决同步问题，这就遗留了两个主要的性能问题：1.互斥同步会阻塞其他线程，当阻塞线程过多时容易使CPU假死，严重影响系统吞吐率和故障率；2.JVM调用硬件线程能力，就需要不断的从用户态（JVM）和内核态（OS）之间切换，造成了浪费太少了系统压力。通常称这样的互斥同步方式是**重量级同步**，所以那时候的synchronized在并发数量递增过程中，性能会严重下降，在JDK6之后，HotSpot对并发做了大量优化，其中主要包括：偏向锁、轻量级锁、自适应自旋锁、锁消除、锁升级。



**偏向锁**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;偏向锁的目的是，在**无竞争环境中**减少锁带来的性能开销，在对象的对象头中（对象头保存对象的元数据，包括哈希值、GC分代等信息）存在一个ThreadId属性，该属性用于捆绑调用线程的ID，在偏向锁状态下，如果当前线程访问了新的锁对象，那么会判断是否是同一个线程，即ThreadID是否一致，如果是同一个线程，则不会重复获得锁，从而提高了程序的运行性能；如果不是同一个线程，则会被认为存在竞争，会自动将锁对象由偏向锁升级为轻量级锁。

> 偏向（Biased），就是偏袒、偏护的意思，意味锁会偏向于第一个获得他的线程。



**轻量级锁**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;轻量级锁是相对于传统互斥同步的“重量级锁”而言，它的使用前提是**”大部分锁在同步周期内没有竞争“**。当线程第一次持有锁对象时，会通过CAS更新持有状态，更新成功则会进入同步方法执行；更新失败表明存在其他线程竞争的状态，**如果出现两个以上的锁竞争，那么就会自动升级为重量级锁。**



**自适应自旋锁**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在当代CPU多核普及的情况下，已经可以支持线程并行，并且并发的方法通常不会占用过长时间，为了避免用户态和内核态的频繁切换，可以将原本要阻塞的线程再持有时间片期间不阻塞，而是采取自旋的方式（死循环）等待前一个线程释放锁。由此看来，虽然节约了线程切换的开销，但也增加了CPU的运算时间，所以，**”持锁时间越短，自旋效果越好；相反地，持锁时间越长，自旋效果越差。“**因此控制自旋时间或者次数就很有必要，HotSpot默认自旋10次，如果超过10次还没有获得锁则会进入阻塞队列中。当然有个技巧，通常在自旋过程中会附加一些简单的程序用于处理一些业务。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义，自适应自旋锁其实就是自旋锁的自旋次数可以满足自适应的能力，自适应的能力由JVM来判断和赋予，通常是通过判断同一个锁在前一次的自旋时间和持锁线程来决定：如果在同一个锁上自旋等待的时间成功获得了锁，并且持锁的线程正在运行，那么再下一次也被认为有可能成功获得锁，所以允许自旋的次数会增加；如果某个锁很少通过自旋获得，那下一次就直接跳过自旋的方式。



**锁消除和锁粗化**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于即时编译器JIT来讲，代码本身有同步声明，但在逃逸分析过程中发现不存在共享数据，也就不会存在并发问题，因此编译时不会对该代码添加锁，这称为**”锁消除“**。当短时间内出现大量重复的锁，比如循环体内添加锁，编译时就会将锁的控制范围外扩至循环体外，这称为**”锁粗化“**。这两种技术都有效的避免了开发过程中或主观或客观存在的”低效率并发问题“。



### 8.2 锁对象Lock

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JDK1.5新增了java.util.concurrent.Lock接口，旨在提供可以在Java类对象层面实现，并且更加灵活的同步方式。顾名思义，该接口就是“对象锁”，是一种源码级别灵活控制的同步方式，下图展现了Lock接口继承关系。

{% asset_img lock.png lock %}



#### 8.2.1 ReentrantLock

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReentrantLock是Lock接口的重要实现类，称为**”可重入锁“**，其含义是指一个线程可以对同一个锁对象重复访问，访问一次锁的数量会自增，访问结束锁的数量会自减，当锁容量为0时释放该锁。可重入锁是synchronized的超集，在实现效果上与synchronized一致，只不过前者是代码级别的并发控制，而后者属于语法级别的并发控制。synchronized可以通过语法自动实现加锁和解锁操作，ReentrantLock可以使开发者灵活的加锁，并且需要主动在finally中释放锁，否则就会出现永远被加锁的情况。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此之外ReetranLock还支持以下主要功能：

1. **可中断**，当锁对象长时间被持有时，等待线程可以选择放弃从而处理其他事情（ *tryLock() 方法*）。
2. **公平和非公平竞争**，synchronized是典型的非公平竞争，当锁对象被释放之后，所有阻塞队列中的线程都可以竞争该锁。ReentrantLock不仅支持非公平竞争，还支持公平竞争，它是指锁对象被释放之后，阻塞队列中的线程按照时间顺序依次获得锁，但需要知道公平竞争将会产生性能问题影响系统吞吐率。ReentrantLock拥有私有属性Sync，而从上图中可以看到Sync的实现类包含公平锁FairSync和非公平锁UnFairSync，默认情况使用UnFairSync，也可以通过构造器来声明使用FairSync。

```java
// ReentrantLock重要属性和构造器
public class ReentrantLock implements Lock, java.io.Serializable {
    private final Sync sync;
    
    public ReentrantLock() {
        sync = new NonfairSync();
    }
    
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
}
```

```java
// synchronized
class SynchronizedDemo {
    private Object param;

    public synchronized Object getParam() { 
        return param;
    }

    public synchronized void setParam(Object param) { 
        this.param = param;
    }

    public static void main(String[] args) {
        SynchronizedDemo demo = new SynchronizedDemo();
        demo.getParam();
        demo.setParam(new Object());
    }
}

// ReentrantLock
static class SynchronizedDemo {
    private Object param;

    public Object getParam() {
        return param;
    }

    public void setParam(Object param) {
        this.param = param;
    }

    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();
        SynchronizedDemo demo = new SynchronizedDemo();
        lock.lock();
        demo.getParam();
        demo.setParam(new Object());
        lock.unlock();
    }
}
```



3. **多条件绑定**，synchronized通过wait()和notify()来实现一个关联条件，当需要更多的关联条件时就不得不添加更多的锁。ReentranLock只需要通过多次调用newCondition()方法即可满足。



#### 8.2.2 多条件绑定——Condition对象



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Condition对象称为线程监视器，支持更加精准的线程调度动作。传统的线程调度通过Object对象的 wait() 方法和 notify() 或 notifyAll() 对象实现，这也是synchronized互斥锁支持的线程调度方式，但其中存在两个问题：

1. notifyAll会唤醒当前所有阻塞线程竞争锁，是一种非公平竞争，唤醒粒度面向整个线程队列。
2. notify只会唤醒阻塞队列中的一个线程，置于唤醒哪一个线程则是由线程调度器决定，用户并不能指定线程唤醒，虽然唤醒粒度小但无法指定线程。

对于ReentranLock可以通过注册多条监视器来显式的、准确的实现线程调度，以下分别以简化版经典的生产者消费者问题对二者做以比较。



> 描述：假设有action1和action2两个动作，两动作需要前后依次循环执行。



```java
// synchronized版本实现
public class SyncProducerAndConsumer {
    private static volatile AtomicInteger state = new AtomicInteger(0); // 调度状态，保证原子和可见

    private static class Conductor {

        public void action1() throws InterruptedException {
            synchronized (this) {
                while (state.get() != 0) { // 状态不为0时等待
                    this.wait();
                }
                // 状态为0时处理
                System.out.println(Thread.currentThread().getName() + " execute");
                // 执行结束前修改状态并唤醒其他线程
                state.set(1);
                notifyAll(); // 此例中只有两个子线程，也可使用notify()
            }
        }

        public void action2() throws InterruptedException {
            synchronized (this) {
                while (state.get() != 1) {
                    this.wait();
                }
                System.out.println(Thread.currentThread().getName() + " execute");
                state.set(0);
                notifyAll();
            }
        }
    }
    
    public static void main(String[] args) {
        Conductor conductor = new Conductor();
        new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    conductor.action1();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"Thread1").start();

        new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    conductor.action2();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"Thread2").start();
    }
}
```



```java
// ReentrantLock实现
public class LockProducerAndConsumer {
    private static volatile AtomicInteger state = new AtomicInteger(0);

    private static class Conductor {
        private final Lock lock = new ReentrantLock(); // 可重入锁
        private final Condition action1Monitor = lock.newCondition(); // 注册action1监视器
        private final Condition action2Monitor = lock.newCondition(); // 注册action2监视器

        public void action1() throws InterruptedException {
            lock.lock(); 
            try {
                while (state.get() != 0) {
                    action1Monitor.await(); // 状态不为0，等待
                }
                // 执行
                System.out.println(Thread.currentThread().getName() + " execute");
                state.set(1);
                action2Monitor.signal(); // 指定唤醒action2监视器的线程
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }

        public void action2() throws InterruptedException {
            lock.lock();
            try {
                while (state.get() != 1) {
                    action2Monitor.await();
                }
                System.out.println(Thread.currentThread().getName() + " execute");
                state.set(0);
                action1Monitor.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        Conductor conductor = new Conductor();
        new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    conductor.action1();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"Thread1").start();

        new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    conductor.action2();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"Thread2").start();
    }
}
```

总结：

1. Synchronized使用 wait() 、notify()、notifyAll()方法实现线程调度。调度粒度大，无法指定固定线程的调度。
2. ReentranLock使用Condition提高的await()、signal()、signalAll()方法实现线程调度，可以准确唤醒指定线程。



### 8.2.3 Lock-Free：CAS

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;笼统的从策略来讲，锁可以分为以 synchronized 和 reentrant lock 为代表的互斥阻塞式锁，称为**悲观锁**，悲观锁总是认为如果不采取同步措施那就一定会发生并发安全问题，所以无论变量是否存在竞争都加锁；另一类是以CAS为代表的非阻塞式锁，称为**乐观锁**，乐观锁认为无论如何先执行操作，如果操作的结果不符合预期再考虑补救措施。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**CAS （Compare and Swap）**，是一种Lock Free编程类型，通过编码的形式保证并发安全，这个概念不仅应用于硬件层面，同样应用于软件层面，比如通过编程语言从源码层面解决，或者某些数据库也支持保证数据一致性。CAS执行包含三个要素，数据的内存位置M、预期值P、新值N，当且仅当M的数值与P相等才会更新新值N，否则就不执行更新操作，可以通过有限制次数的自旋来重试，直到更新成功或者退出。整个过程是具有原子性的，不会被其他线程中断。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java9以前，Java API支持的CAS属于**sun.misc.Unsafe**，只有通过Bootstrap类加载器加载的类才有使用权限，因此类库中的类比如JUC可以使用，用户类可以通过反射机制获得访问和调用权限，Java9面向用户开放了VarHandle类用于操作CAS。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再前篇多线程特性——原子性时已经介绍过AtomicInteger类中自增操作使用CAS，这里就不再獒述。



### 8.3 死锁

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计不当的多线程任务很容发生死锁现象，而且死锁的发生通常意味着系统资源走向枯竭出现假死甚至宕机现象。死锁的发生主要是因为多线程在持有锁的执行过程中阻塞获得其他的锁，此时这个锁被其他线程持有并且尝试获得各自持有的锁。

```java
public class DeadLockDemo {

    public static void main(String[] args) {
        Object obj1 = new Object();
        Object obj2 = new Object();
        
        // 线程t1持有obj1对象锁，并尝试获得obj2对象锁
        new Thread(() -> {
            synchronized (obj1) {
                try {
                    System.out.println(Thread.currentThread().getName() + " get obj1");
                    System.out.println(Thread.currentThread().getName() + " try to get obj2,waiting");
                    TimeUnit.SECONDS.sleep(1);
                    synchronized (obj2) {
                        System.out.println(Thread.currentThread().getName() + " get obj2");
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t1").start();
        
        // 线程t2持有obj2对象锁，并尝试获得obj1对象锁
        new Thread(() -> {
            synchronized (obj2) {
                try {
                    System.out.println(Thread.currentThread().getName() + " get obj2");
                    System.out.println(Thread.currentThread().getName() + " try to get obj1,waiting");
                    TimeUnit.SECONDS.sleep(1);
                    synchronized (obj1) {
                        System.out.println(Thread.currentThread().getName() + " get obj1");
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t2").start();
    }
}

// 最终t1和t2产生死锁，系统进入无限阻塞
/*
 * output:
t1 get obj1
t1 try to get obj2,waiting
t2 get obj2
t2 try to get obj1,waiting
 */
```

通常解决死锁的方式，要么采用乐观锁通过有限次数的自旋解决；要么对互斥锁设置超时时限，超时的线程释放锁并重新进入阻塞队列。

