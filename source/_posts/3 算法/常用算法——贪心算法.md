---
title: 常用算法——贪心算法
date: 2020-4-1
tags: [算法]
---
{% asset_img image1.jpg 算法 %}

# 贪心算法
<!--more-->

> 每一次站在十字路口，我们总是选择看起来最安全的大路。



## 概念

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;贪心算法，是指将一个问题拆解成多个子问题，而在解决子问题时，我们总是选择最优方案，也就是说，并不从整体考虑最优解，最终可能是接近最优解的解法。



## 算法框架

1. 一个复杂问题可以拆分位多个最优子结构。
2. 对子问题进行最优解法。
3. 所有子问题的最优解可能是最终最优解的趋近解法。



## 算法举例

> 输入一组整数N的序列A， 满足0<N<10，A的个数为6，每组数据以,分隔
>
> 求：整数组合构成的最大hh:mm:ss时间组合，如果不满足则输出invalid。
>
> 例1
>
> 输入：[3, 2, 4, 9, 5, 5]
>
> 输出：23:59:54
>
> 例2
>
> 输入：[9, 9, 9, 9, 9, 9]
>
> 输出：invalid

思路：最大时间组合，从时分秒依次求得，按照贪心算法思想，每一个求得的最大值，最终组合的必然是最大值。

```java
public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();
        String[] array = input.substring(1, input.length() - 1).split(",");
        List<String> inputList = new ArrayList<>(Arrays.asList(array));
        
    	// hour
        List<String> list1 = recombine(inputList);
        String hour;
        int intHour = list1.stream()
            	.filter(x -> !x.startsWith("0") &&  Integer.valueOf(x) < 23)
                .map(Integer::valueOf).max(Integer::compare).orElse(-1);
        if (intHour == -1) {
            System.out.println("invalid");
            return;
        }
        hour = intHour + "";
        inputList.remove(getIndex(hour.substring(0, 1), inputList));
        inputList.remove(getIndex(hour.substring(1), inputList));

        // min
        List<String> list2 = recombine(inputList);
        String min;
        int intMin = list2.stream().filter(x -> !x.startsWith("0") &&  Integer.valueOf(x) < 60)
                .map(Integer::valueOf).max(Integer::compare).orElse(-1);
        if (intMin == -1) {
            System.out.println("invalid");
            return;
        }
        min = intMin + "";
        inputList.remove(getIndex(min.substring(0, 1), inputList));
        inputList.remove(getIndex(min.substring(1), inputList));

        // second
        List<String> list3 = recombine(inputList);
        String second;
        int intSecond = list3.stream().filter(x -> !x.startsWith("0") &&  Integer.valueOf(x) < 60)
                .map(Integer::valueOf).max(Integer::compare).orElse(-1);
        if (intSecond == -1) {
            System.out.println("invalid");
            return;
        }
        second = intSecond + "";
        System.out.println(String.join(":", hour, min, second));
    }

    private static List<String> recombine(List<String> list) {
        List<String> newList = new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            for (int j = 0; j < list.size(); j++) {
                if (i != j) {
                    newList.add(list.get(i) + list.get(j));
                }
            }
        }
        return newList;
    }

    private static int getIndex (String target, List<String> list) {
        int ret = -1;
        for (int index = 0; index < list.size(); index++) {
            if (list.get(index).equals(target)) {
                ret = index;
                break;
            }
        }
        return ret;
    }
```

