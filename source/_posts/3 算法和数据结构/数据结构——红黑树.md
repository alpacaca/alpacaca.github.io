---
title: 常用算法——分治法
date: 2020-4-1
tags: [算法]
---
{% asset_img image1.jpg 算法 %}



# 分治法
<!--more-->

> 分而治之，治而合之

说明：文中动态插图援引微信公众号：《五分钟学算法》

## 概念

​    分治法（Divide and Conquer, D&C），将一个复杂问题纵向拆分为多个最优结构原子问题，再将原子问题的求解合并，组成复杂问题的最终解。递归是分治法的常用手段，也是经典手段。

## 使用条件

1. 复杂问题拆分后就容易求解。
2. 拆分后的原子问题具有最优子结构。
3. 原子问题的解可以合并成复杂问题的解。
4. 原子问题独立存在，不含公共子问题。

## 算法框架

1. 分解：纵向拆分复杂问题为原子问题。
2. 解决：对原子问题进行求解。
3. 合并：将原子问题解合并，组成最终解。

## 算法复杂度

​    一个规模为n的实例可以划分为k个规模为n/k的实例，其中α个实例是需要求解的：

<center>O(N) = αT(n/k) + f(n)</center>

​    f(n)与具体的拆分和合并算法有关。

## 经典算法

**归并排序（Merge Sort）**：

1. 拆分：将一个无序序列递归拆分，最终拆分为长度为1的子序列。
2. 解决：一次将子序列两两返回并进行排序。
3. 合并：自下而上的对子序列进行合并，最终组成完整的排序后序列。

> 自上而下拆分， 自下而上合并

{% asset_img mergesort.gif 算法 %}

```
public class MergeSorted implements IArraySort {

    @Override
    public int[] sort(int[] srcArray) {
        int[] arr = Arrays.copyOf(srcArray, srcArray.length); // 操作副本排序，不影响原数组
        if (arr.length < 2) {
            return arr;
        }
        int middle = srcArray.length / 2;
        int[] leftArr = Arrays.copyOfRange(arr, 0, middle);
        int[] rightArr = Arrays.copyOfRange(arr,  middle, arr.length);
        return merge(sort(leftArr), sort(rightArr));
    }

    private int[] merge(int[] leftArr, int[] rightArr) {
        int[] result = new int[leftArr.length + rightArr.length];
        int index = 0;
        while (leftArr.length > 0 && rightArr.length > 0) {
            if (leftArr[0] <= rightArr[0]) {
                result[index] = leftArr[0];
                index++;
                leftArr = Arrays.copyOfRange(leftArr, 1, leftArr.length);
            } else {
                result[index] = rightArr[0];
                index++;
                rightArr = Arrays.copyOfRange(rightArr, 1, rightArr.length);
            }
        }

        while (leftArr.length > 0) {
            result[index] = leftArr[0];
            index ++;
            leftArr = Arrays.copyOfRange(leftArr, 1, leftArr.length);
        }

        while (rightArr.length > 0) {
            result[index] = rightArr[0];
            index ++;
            rightArr = Arrays.copyOfRange(rightArr, 1, rightArr.length);
        }
        return result;
    }

    public static void main(String[] args) {
        int[] arr = {3,23,4,13,4,5,63,6,2};
        arr = new MergeSorted().sort(arr);
        System.out.println(arr.length);
        for (int i : arr) {
            System.out.print(i + " ");
        }
    }
}
```

**快速排序（Quick Sort）**

1. 解决：设置基准点pivot，并定位两端索引位置left和right，一边排序找到比pivot小的放在左边，比pivot大的放在右边。
2. 拆分：一边排序后，以pivot为分割点，将左右两边序列依次执行步骤1。
3. 合并：将原子序列排序后合并成为最终有序序列。

> 自上而下排序并拆分

{% asset_img quicksort.gif 算法 %}

```
public class QuikSort implements IArraySort {

    @Override
    public int[] sort(int[] sourceArray) {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
        quickSort(arr, 0, arr.length - 1);
        return arr;
    }

    private void quickSort(int[] arr, int left, int right) {
        if (left > right) {
            return;
        }
        int leftIndex = left;
        int rightIndex = right;
        int pivot = arr[leftIndex]; // 基准
        while (left < right) {
            while (left < right && arr[right] >= pivot) {
                right--;
            }
            while (left < right && arr[left] <= pivot) {
                left++;
            }

            if (left < right) {
                swap(arr, right, left);
            }
        }
        swap(arr, leftIndex, left); // 此时left==right
        quickSort(arr, leftIndex, left-1);
        quickSort(arr,left + 1, rightIndex);
    }


    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr = {6,1,2,7,9,3,4,5,10,8};
        arr = new QuikSort().sort(arr);
        System.out.println(arr.length);
        for (int i : arr) {
            System.out.print(i + " ");
        }
    }
}
```

**注意**：如果基准点pivot设置为左顶端数，那么应该保证先从右侧开始比较，这样可以保证最终left和right停留的相同位置是小于pivot的，所以可以交换，否则，交换的将是大于pivot的值，不满足快排条件。

**汉诺塔**

A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数

把n-1个盘子由A 移到 B；把第n个盘子由 A移到 C；把n-1个盘子由B 移到 C；

{% asset_img hanoi.gif 算法 %}

```
public class Hanoi {

    private static int step = 1; // 步数

    public static void hanoi(int plateNum, String a, String b, String c) {
        if (plateNum == 1) {
            move(plateNum, a, c);
        } else {
            hanoi(plateNum - 1, a, c, b);
            move(plateNum, a, c);
            hanoi(plateNum - 1, b, a, c);
        }
    }

    private static void move(int plateNum, String from, String to) {
        System.out.printf("%d step, %d plate move from %s to %s \n", step++, plateNum, from, to);
    }

    public static void main(String[] args) {
        hanoi(3, "A", "B", "C");
    }
}
1 step, 1 plate move from A to C 
2 step, 2 plate move from A to B 
3 step, 1 plate move from C to B 
4 step, 3 plate move from A to C 
5 step, 1 plate move from B to A 
6 step, 2 plate move from B to C 
7 step, 1 plate move from A to C
```