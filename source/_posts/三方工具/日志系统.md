---
title: 日志系统
date: 2020-7-1
tags: [第三方工具, Log]
---
{% asset_img image1.jpg 日志系统 %}

# 日志系统
<!--more-->

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现代日志系统主要通过 **SLF4J** 日志门面框架 (Simple Logging Facade) 集成各实际使用日志框架，如 log4j、log4j2、logback等。由于 log4j2 是 log4j 的升级版本，所以主要介绍 log4j2 和 logback 的详细配置。



## 1 SLF4J

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在早期日志系统的演化过程中，日志都是强依赖于某个特定的框架，如果遇到系统升级或者更换日志框架就会因为侵入式使用而备受煎熬，SLF4J是一款日志门面框架，它不提供特定的日志功能，只是整合系统具体使用的日志框架，比如开发中用SLF4J定义日志系统，具体框架可以使Log4J或者Logback，二者更换依赖也不会影响现有系统的使用。

> SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired *at compile time* to use one and only one specific logging framework

SLF4J不依赖于任何特殊的类装入器机制。实际上，每个SLF4J绑定都是在编译时硬连接的，以使用且仅使用一个特定的日志记录框架

{% asset_img slf4j.png slf4j %}



## 2.1 Log4j2 配置文件详解

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log4j2 不再支持 prorperties 配置文件，仅支持 xml 和 json 文件。系统按照以下顺序从 classpath 路径下匹配日志配置文件 : log4j2-text.json => log4j2-text.xml => log4j2.json => log4j2.xml。



> 完整的 xml 配置文件：



```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- status用于设置log4j2自身内部的信息输出，可以不设置 -->
<configuration>
    <!--全局参数-->
    <Properties>
        <Property name="pattern">[%d{yyyy-MM-dd HH:mm:ss.SSS}] %-5level %class{36} [line:%L] %M - %msg%xEx%n</Property>
        <Property name="rootFileName">./logs/root.log</Property>
        <Property name="debugFileName">./logs/debug.log</Property>
        <Property name="druidFileName">./logs/druid-sql.log</Property>
        <Property name="rootFilePattern">logs/$${date:yyyy-MM}/root-%d{yyyy-MM-dd}-%i.log.gz</Property>
        <Property name="druidFilePattern">logs/$${date:yyyy-MM}/druid-%d{yyyy-MM-dd}-%i.log.gz</Property>
        <Property name="maxSize">50 MB</Property>
    </Properties>
        
    <appenders>
        <!-- 控制台配置 -->
        <Console name="Console" target="SYSTEM_OUT">
            <ThresholdFilter level="DEBUG" onMatch="ACCEPT" onMismatch="DENY"/>
            <PatternLayout>
                <Pattern>${pattern}</Pattern>
            </PatternLayout>
        </Console>

        <!-- 处理INFO级别的日志，并放到logs/info.log文件中，接受 INFO 及以上的日志-->
        <RollingFile name="RootLog" fileName="${rootFileName}" filePattern="${rootFilePattern}">
            <Filters>
                <ThresholdFilter level="INFO"/>
            </Filters>
                        
            <PatternLayout>
                <Pattern>${pattern}</Pattern>
            </PatternLayout>
                        
            <Policies>
                <SizeBasedTriggeringPolicy size="${maxSize}"/>
                <TimeBasedTriggeringPolicy/>
            </Policies>
        </RollingFile>

        <!-- 处理DEBUG级别的日志-->
        <RollingFile name="DebugLog" fileName="${debugFileName}" filePattern="${rootFilePattern}">
            <ThresholdFilter level="DEBUG"/>
                        
            <PatternLayout>
                <Pattern>${pattern}</Pattern>
            </PatternLayout>
                        
            <Policies>
                <SizeBasedTriggeringPolicy size="${maxSize}"/>
                <TimeBasedTriggeringPolicy/>
            </Policies>
        </RollingFile>
        
        <!-- Druid的日志记录追加器 -->
        <RollingFile name="DruidLog" fileName="${druidFileName}" filePattern="${druidFilePattern}">
            <PatternLayout>
                <Pattern>${pattern}</Pattern>
            </PatternLayout>

            <Policies>
                <SizeBasedTriggeringPolicy size="100 MB"/>
                <TimeBasedTriggeringPolicy/>
            </Policies>
        </RollingFile>
            
    </appenders>
       
    <loggers>
        <root level="DEBUG">
            <appender-ref ref="RootLog"/>
            <appender-ref ref="Console"/>
            <appender-ref ref="DebugLog"/>
        </root>

        <!--过滤掉spring和mybatis的一些无用的DEBUG信息-->
        <logger name="org.springframework" level="INFO" />
        <logger name="org.mybatis" level="INFO" />

        <!-- 记录druid-sql的记录 -->
        <logger name="druid.sql.Statement" level="DEBUG" additivity="false">
            <appender-ref ref="DruidLog"/>
        </logger>
    </loggers>
</configuration>
```

1. 日志级别包括: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL。
   - All : 打开所有日志记录。
   - TRACE: 追踪日志记录。
   - `DEBUG` : 调试应用程序是非常有帮助。
   - `INFO` : 粗粒度级别上突出强调应用程序的运行过程。
   - `WARN` : 输出警告的日志。
   - `ERROR` : 输出错误信息日志。
   - FATAL : 输出每个严重的错误事件将会导致应用程序的退出的日志。
   - OFF : 关闭所有日志记录。

2. Configuration有两个属性:status和monitorinterval,有两个子节点:Appenders和Loggers。status用来指定log4j本身的打印日志的级别，monitorinterval用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s。

3. Appenders节点，常见的有三种子节点:Console、RollingFile、File：

   **Console**节点用来定义输出到控制台的Appender：

   - name:指定Appender的名字; 

   - target:SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT; 

   - PatternLayout:输出格式，不设置默认为:%m%n。

     

   **File**节点用来定义输出到指定位置的文件的Appender：

   - name:指定Appender的名字；
   - fileName:指定输出日志的目的文件带全路径的文件名；
   - PatternLayout:输出格式，不设置默认为:%m%n。

   

   **RollingFile**节点用来定义超过指定大小自动删除旧的创建新的的Appender：

   - name:指定Appender的名字；
   - fileName:指定输出日志的目的文件带全路径的文件名；
   - PatternLayout:输出格式，不设置默认为:%m%n；
   - filePattern:指定新建日志文件的名称格式；
   - Filters:决定日志事件能否被输出，过滤条件有三个值：ACCEPT、DENY、NEUTRAL。
   - ThresholdFilter: 如果目标 level 大于等于配置中的 level ,那么该日志进入过滤，由过滤策略决定是保留（OnMatch="ACCEPT"）还是舍弃（OnMatch="DENY"）,默认策略是NEUTRAL，即进入下一级过滤器判断，如果当前过滤器是最后一个过滤器，则为ACCEPT；如果不匹配则进入 onMisMatch ,默认 DENY。

   ```text
   # 打个比方
   <Filters>
       <ThresholdFilter level="INFO"/>
       <ThresholdFilter level="WARN" onMatch="DENY" onMismatch="NEUTRAL"/>
   </Filters>
   
   # OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL
   # 该过滤器表示,如果当前日志 level >= INFO，则进入默认匹配 onMatch="NEUTRAL"，NEUTRAL表示进入下# 一级过滤器；下一级过滤器表示，如果当前日志 level >= WARN 则匹配onMatch="DENY"拒绝接收，所以该
   # 过滤器表示只接收 INFO 日志
   
   ```

   

   - Policies:指定滚动日志的策略，就是什么时候进行新建日志文件输出日志；
   - TimeBasedTriggeringPolicy:Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1 hour。modulate=true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am...而不是7am；
   - SizeBasedTriggeringPolicy:Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小；
   - DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性)。

4. Loggers节点，常见的有两种:Root和Logger：

   **Root**节点用来指定项目的根日志，如果没有指定Logger，那么就会默认使用该Root日志输出。

   **Logger**节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。



## 3 Log4j2 和 SLF4J

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前环境：

- JDK 11
- Maven 3.6.3 （国内采用aliyun镜像）

```java
	<dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-api</artifactId>
      <version>2.8.2</version>
    </dependency>
        
    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-core</artifactId>
      <version>2.8.2</version>
    </dependency>
        
    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-slf4j-impl</artifactId>
      <version>2.8.2</version>
    </dependency>
```

`注意`，在个别文章中介绍依赖时，还引入了slf4j，这里需要说明的是，如果引入了`log4j-slf4j-impl`就无需在单独引入`slf4j`，否则在日志工厂 LoggerFactory 获得具体日志实现框架时会因为存在多个日志框架而产生问题。

```java
// 测试
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class App {
    private static Logger LOG = LoggerFactory.getLogger(App.class);

    public static void main(String[] args) {
        LOG.debug("{} say hi", "debug");
        LOG.info("{} say hi", "info");
        LOG.warn("{} say hi", "warn");
        LOG.error("{} say hi", "error");
    }
}

// output:
// [17:33:26.532] DEBUG org.example.App [line:14] main - debug say hi
// [17:33:26.533] INFO  org.example.App [line:15] main - info say hi
// [17:33:26.533] WARN  org.example.App [line:16] main - warn say hi
// [17:33:26.533] ERROR org.example.App [line:17] main - error say hi

// ./logs 目录下创建日志文件debug.log、 root.log、 druid-sql.log
```



## 4 Logback 配置及应用

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logback是由 log4j 创始人设计的另一个开源日志框架，它取代 Log4J 的理由如下：

- 更快的实现：Logback的重写内核，在关键执行路径上性能提升10倍以上;

- 更小的内存：初始化内存加载更小；

- 非常自然实现了SLF4j：充分利用 SLF4J 的接口去实现，减少门面框架适配所带来的中间层开销；

  由于 Logback 配置与 Log4J2 很相似，所以具体配置就不多介绍，直接给出较为完整的配置：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="false">
    <!-- 全局参数 -->
    <Property name="encoding" value="UTF-8" />
    <Property name="rootFileName" value="./logs/root.log" />
    <Property name="debugFileName" value="./logs/debug.log" />
    <Property name="rootFilePattern" value="./logs/$${date:yyyy-MM}/root-%d{yyyy-MM-dd}-%i.log.gz" />
    <Property name="debugFilePattern" value="./logs/$${date:yyyy-MM}/debug-%d{yyyy-MM-dd}-%i.log.gz" />
    <Property name="maxSize" value="50 MB" />
    <Property name="maxHistory" value="30" />
    <Property name="pattern" value="[%d{yyyy-MM-dd HH:mm:ss.SSS}] %-5level %class{36} [line:%L] %M - %msg%xEx%n" />
    <!-- %d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n -->
    <!-- %d{yyyy-MM-dd HH:mm:ss} %-4relative [%thread] %-5level %logger{35} - %msg %n -->
    <!-- [ %-5level] [%date{yyyy-MM-dd HH:mm:ss.SSS}] %logger{96} [%line] [%thread]- %msg%n  -->

    <!-- 控制台输出 -->
    <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <charset>${encoding}</charset>
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
            <pattern>${pattern}</pattern>
        </encoder>
    </appender>

    <!-- Root日志 -->
    <appender name="RootLog" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${rootFileName}</file>

        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>INFO</level>
        </filter>

        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <charset>${encoding}</charset>
            <pattern>${pattern}</pattern>
        </encoder>

        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <FileNamePattern>${rootFilePattern}</FileNamePattern>
            <!--日志文件保留天数-->
            <MaxHistory>${maxHistory}</MaxHistory>
        </rollingPolicy>

        <!--日志文件最大的大小-->
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <MaxFileSize>${maxSize}</MaxFileSize>
        </triggeringPolicy>
    </appender>

    <!-- Debug日志 -->
    <appender name="DebugLog" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${debugFileName}</file>

        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>DEBUG</level>
        </filter>

        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <charset>${encoding}</charset>
            <pattern>${pattern}</pattern>
        </encoder>

        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <FileNamePattern>${debugFilePattern}</FileNamePattern>
            <!--日志文件保留天数-->
            <MaxHistory>${maxHistory}</MaxHistory>
        </rollingPolicy>

        <!--日志文件最大的大小-->
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <MaxFileSize>${maxSize}</MaxFileSize>
        </triggeringPolicy>
    </appender>

    <!-- 日志输出级别 -->
    <root level="DEBUG">
        <appender-ref ref="Console" />
        <appender-ref ref="RootLog" />
        <appender-ref ref="DebugLog" />
    </root>
</configuration>
```



```xml
<!-- pom -->
	<dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.25</version>
    </dependency>

    <dependency>
      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-classic</artifactId>
      <version>1.2.3</version>
    </dependency>

    <dependency>
      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-core</artifactId>
      <version>1.2.3</version>
    </dependency>
```



```java
// 测试
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class App {
    private static Logger LOG = LoggerFactory.getLogger(App.class);

    public static void main(String[] args) {
        LOG.debug("{} say hi", "debug");
        LOG.info("{} say hi", "info");
        LOG.warn("{} say hi", "warn");
        LOG.error("{} say hi", "error");
    }
}

// output
// [2020-07-11 19:02:38.822] DEBUG org.example.App [line:14] main - debug say hi
// [2020-07-11 19:02:38.825] INFO  org.example.App [line:15] main - info say hi
// [2020-07-11 19:02:38.825] WARN  org.example.App [line:16] main - warn say hi
// [2020-07-11 19:02:38.825] ERROR org.example.App [line:17] main - error say hi

// 输出root.log、debug.log文件
```



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从配置文件中可以看出 Logback 是接受定制化开发的，即自定义类并实现对应的接口，最后在配置文件`class`中配置，最常用的定制化开发就是针对过滤器 **Filter**，通过实现`ch.qos.logback.core.filter.Filter`接口，在 decide() 方法中重写逻辑，就可以实现自定义过滤器，最后通过配置即可使用。



```java
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.filter.Filter;
import ch.qos.logback.core.spi.FilterReply;

public class MyFilter extends Filter<ILoggingEvent> {
    @Override
    public FilterReply decide(ILoggingEvent iLoggingEvent) {
        String msg = iLoggingEvent.getMessage();
        if (Strings.isNullOrEmpty(msg) && "MYFILTER".equals(msg))){
            return FilterReply.ACCEPT;
        }
        return  FilterReply.DENY;
    }
}
```



```xml
<filter class="xxx.xxx.MyFilter">
    <level>MYFILTER</level>
</filter>
```



