---
title: 常用算法——动态规划法
date: 2020-4-7
tags: [算法]
---
{% asset_img image1.jpg 算法 %}



# 动态规划法
<!--more-->

## 概念

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态规划法，是指将一个问题拆解成多个子问题，若干子问题的解是其他子问题的条件，而这些子问题构成了局部最优解，并最终得到整体问题的解。它与分治法最大的区别在于具有公共子问题，即它不是独立的。常用递推方式解决。

1. 有最优子结构特征。
2. 无后效性，子问题的状态一旦确定，不受其后操作的影响。
3. 重叠子问题：分治法讲求无公共子问题，而动态规划法要求，每个子问题并不是独立的，前一子问题状态会应用于后一子问题。



## 算法框架

1. 定义状态方程F(i,j)=A(i,j)
2. 定义状态转移方程F(i,j)=max(F(i-1,j),F(i-1,B(j))) | F(i-1,j)
3. 构造关于i和j的动态规划表并填表。



## 算法举例

> 01背包问题：
>
> 描述：在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），每件物品都有其价值P1,P2……Pn（Pi为整数）。求如何让背包装入最大价值的物品。

> 思路：
>
> 1. 拆分：将该问题拆分，记录存入物品编号与背包容量的矩阵。
> 2. 状态转移：假设当前的商品编号为i，背包容量为j，商品价值为P(i)，重量为W(i)，那么当前背包容量对应放入的商品最大价值为V(i,j)
> 	(1) 当前商品重量>背包重量无法放入，那么最大价值等于该容量下的上一个商品的最大价值，
>         即W(i) > j, 则V(i,j) = V(i-1,j)
> 	(2) 当前商品重量>背包重量可以放入，那么需要衡量如果将该商品放入背包是否能产生最大价值，如果不满足也不放。
>         即W(i) <= j, 则 V(i,j) = max(V(i-1, j - W(i)) + P(i), V(i-1, j))
> 3. 求V(i,j)中的最大值即背包容纳的最大价值。

```java
public class Knapsack {

    static int maxValueOfKnapsack(int[] weights, int[] values, int capacity) {
        int[][] dpTable = new int[values.length][capacity + 1];
        int maxValue = 0;
        // DP问题都是从(1,1)开始
        for (int i = 1; i < values.length; i++) {
            for (int j = 1; j <= capacity; j++) {
                if (weights[i] > j) { // 放不下
                    dpTable[i][j] = dpTable[i-1][j];
                } else {
                    // 衡量价值
                    // dpTable[i-1][j-weights[i]] + values[i]表示放入商品之后对应的价值
                    dpTable[i][j] = Math.max(dpTable[i-1][j-weights[i]] + values[i], dpTable[i-1][j]);
                }

                if (maxValue < dpTable[i][j]) {
                    maxValue = dpTable[i][j];
                }
            }
        }
        return maxValue;
    }

    public static void main(String[] args) {
        int[] weights = {0, 8, 10, 6, 3, 7, 2};
        int[] values = {0, 4, 6, 2, 2, 5, 1};
        int capacity = 16;
        System.out.println(maxValueOfKnapsack(weights, values, capacity));
    }
}
```

